import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool


class CheckAuthorization(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, requester_email: str) -> str:
        """
        Check authorization for Incident Management actions.
        Uses two-tier logic with fallback:
        1. If requester has an authorized role → authorized
        2. If requester lacks an authorized role but has an 'approved' approval record from someone with an authorized role → authorized
        3. Otherwise → not authorized
        
        Args:
            data: Environment data containing users and approvals
            action: The incident management action being performed
            requester_email: Email of the user requesting the action
            
        Returns:
            JSON string with authorization result
        """
        # Single source of truth for all actions and their authorized roles
        ACTIONS = {
            "create_client": ["system_administrator", "incident_manager", "account_manager"],
            "update_client": ["system_administrator", "incident_manager", "account_manager"],
            "create_user": ["system_administrator", "incident_manager"],
            "update_user": ["system_administrator", "incident_manager"],
            "deactivate_user": ["system_administrator", "incident_manager"],
            "create_vendor": ["system_administrator", "incident_manager", "executive"],
            "update_vendor": ["system_administrator", "incident_manager", "executive"],
            "create_product": ["system_administrator", "incident_manager", "executive"],
            "update_product": ["system_administrator", "incident_manager", "executive"],
            "create_component": ["system_administrator", "technical_support", "incident_manager"],
            "update_component": ["system_administrator", "technical_support", "incident_manager"],
            "create_subscription": ["account_manager", "incident_manager", "executive"],
            "update_subscription": ["account_manager", "incident_manager", "executive"],
            "create_sla": ["account_manager", "system_administrator", "executive"],
            "update_sla": ["account_manager", "system_administrator", "executive"],
            "create_incident": ["incident_manager", "technical_support", "system_administrator", "executive"],
            "update_incident": ["incident_manager", "technical_support", "system_administrator", "executive"],
            "resolve_incident": ["incident_manager", "technical_support", "executive"],
            "close_incident": ["incident_manager", "technical_support"],
            "create_communication": ["incident_manager", "technical_support", "system_administrator", "account_manager"],
            "update_communication": ["incident_manager", "technical_support", "system_administrator", "account_manager"],
            "create_workaround": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "update_workaround": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "conduct_rca": ["technical_support", "incident_manager"],
            "update_rca": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "create_escalation": ["incident_manager", "technical_support", "system_administrator", "executive", "account_manager"],
            "update_escalation": ["incident_manager", "technical_support", "system_administrator", "executive"],
            "create_change_request": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "update_change_request": ["technical_support", "incident_manager", "system_administrator", "executive"],
            "create_rollback_request": ["technical_support", "system_administrator", "incident_manager"],
            "update_rollback_request": ["incident_manager", "system_administrator", "executive"],
            "record_metrics": ["incident_manager", "system_administrator"],
            "update_metrics": ["incident_manager", "system_administrator"],
            "generate_report": ["incident_manager", "executive"],
            "update_report": ["incident_manager", "executive"],
            "create_kb_article": ["technical_support", "incident_manager"],
            "update_kb_article": ["technical_support", "incident_manager"],
            "create_pir": ["incident_manager", "executive"],
            "update_pir": ["incident_manager", "executive"],
            "initiate_bridge": ["incident_manager", "technical_support", "executive"],
            "close_bridge": ["incident_manager", "technical_support"],
            "request_approval": ["technical_support", "system_administrator", "incident_manager"],
            "approve_request": ["incident_manager", "executive"],
            "update_communication_status": ["incident_manager", "technical_support", "system_administrator"],
            "create_work_note": ["incident_manager", "technical_support", "system_administrator"],
            "update_work_note": ["incident_manager", "technical_support", "system_administrator"],
            "create_attachment": ["incident_manager", "technical_support", "system_administrator", "client_contact"],
            "update_escalation_status": ["incident_manager", "executive", "technical_support"],
            "update_approval_request": ["incident_manager", "system_administrator"]
        }
        
        # Actions that may require approval under certain conditions
        APPROVAL_REQUIRED_ACTIONS = [
            "create_escalation",
            "initiate_bridge",
            "create_rollback_request",
            "create_change_request",
            "close_incident",
            "conduct_rca"
        ]
        
        # Find the requester's role and user_id
        users = data.get("users", {})
        requester_role = None
        requester_user_id = None
        for user_id, user in users.items():
            if user.get("email") == requester_email:
                requester_role = user.get("role")
                requester_user_id = user_id
                break
        
        if not requester_role:
            return json.dumps({
                "authorized": False,
                "error": f"No user found with email: {requester_email}"
            })
        
        # Check if the action is defined
        if action not in ACTIONS:
            return json.dumps({
                "authorized": False,
                "error": f"Unknown action: {action}"
            })
        
        authorized_roles = ACTIONS[action]
        
        # TIER 1: Check if requester has direct authorization
        if requester_role in authorized_roles:
            return json.dumps({
                "authorized": True,
                "message": f"User with role '{requester_role}' is directly authorized to perform action '{action}'"
            })
        
        # TIER 2: Requester not directly authorized, check for an explicit approval
        # This only applies to actions that support the approval workflow
        if action in APPROVAL_REQUIRED_ACTIONS:
            approvals = data.get("approvals", {})
            
            for approval in approvals.values():
                # Check for a matching, approved record for the specific requester and action
                approval_requested_by = approval.get("requested_by")
                
                # Match by user_id
                if str(approval_requested_by) != str(requester_user_id):
                    continue
                    
                # Check if this approval is for the action being requested
                # Map action names to approval request patterns
                approval_action_match = False
                requested_action = approval.get("requested_action", "")
                
                if action == "create_escalation" and "Escalation approval" in requested_action:
                    approval_action_match = True
                elif action == "initiate_bridge" and "Bridge initiation approval" in requested_action:
                    approval_action_match = True
                elif action == "create_rollback_request" and "Rollback approval" in requested_action:
                    approval_action_match = True
                elif action == "create_change_request" and "change approval" in requested_action.lower():
                    approval_action_match = True
                elif action == "close_incident" and "Incident Closure approval" in requested_action:
                    approval_action_match = True
                elif action == "conduct_rca" and "Rca approval" in requested_action:
                    approval_action_match = True
                
                if approval_action_match and approval.get("status") == "approved":
                    # Get the approver's role
                    approver_user_id = approval.get("approver")
                    approver_role = None
                    
                    for user_id, user in users.items():
                        if str(user_id) == str(approver_user_id):
                            approver_role = user.get("role")
                            break
                    
                    # Check if the approver has an authorized role
                    if approver_role and approver_role in authorized_roles:
                        return json.dumps({
                            "authorized": True,
                            "message": f"User '{requester_email}' has a valid approval from user with role '{approver_role}' for action '{action}'"
                        })
        
        # No direct authorization or valid approval found
        return json.dumps({
            "authorized": False,
            "error": f"Role '{requester_role}' is not authorized for action '{action}', and no valid approval was found. Authorized roles: {', '.join(authorized_roles)}."
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """Return the function schema for tool registration."""
        return {
            "type": "function",
            "function": {
                "name": "check_authorization",
                "description": "Validates authorization for Incident Management actions. First checks if the requester's role is directly authorized. If not, checks for an approved approval record from a user who has an authorized role.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "The incident management action being performed. Valid actions: create_client, update_client, create_user, update_user, deactivate_user, create_vendor, update_vendor, create_product, update_product, create_component, update_component, create_subscription, update_subscription, create_sla, update_sla, create_incident, update_incident, resolve_incident, close_incident, create_communication, update_communication, create_workaround, update_workaround, conduct_rca, update_rca, create_escalation, update_escalation, create_change_request, update_change_request, create_rollback_request, update_rollback_request, record_metrics, update_metrics, generate_report, update_report, create_kb_article, update_kb_article, create_pir, update_pir, initiate_bridge, close_bridge, request_approval, approve_request, update_communication_status, create_work_note, update_work_note, create_attachment, update_escalation_status, update_approval_request"
                        },
                        "requester_email": {
                            "type": "string",
                            "description": "Email of the user requesting the action"
                        }
                    },
                    "required": ["action", "requester_email"]
                }
            }
        }import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverAssets(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover asset entities (products, configuration_items). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - products: Product records
        - configuration_items: Configuration Item (CI) records
        """
        if entity_type not in ["products", "configuration_items"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'products' or 'configuration_items'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    # Add appropriate ID field based on entity type
                    if entity_type == "products":
                        id_field = "product_id"
                    else:  # configuration_items
                        id_field = "ci_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "products":
                    id_field = "product_id"
                else:  # configuration_items
                    id_field = "ci_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_assets",
                "description": "Discover asset entities (products, configuration items). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'products' or 'configuration_items'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "product_id": {
                                    "type": "string",
                                    "description": "Product ID (for products)"
                                },
                                "product_name": {
                                    "type": "string",
                                    "description": "Product name (for products)"
                                },
                                "product_code": {
                                    "type": "string",
                                    "description": "Product code (for products)"
                                },
                                "description": {
                                    "type": "string",
                                    "description": "Product description (for products)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status: 'active', 'deprecated', 'retired' (for products)"
                                },
                                "ci_id": {
                                    "type": "string",
                                    "description": "Configuration Item ID (for configuration_items)"
                                },
                                "ci_name": {
                                    "type": "string",
                                    "description": "Configuration Item name (for configuration_items)"
                                },
                                "ci_type": {
                                    "type": "string",
                                    "description": "CI type: 'server', 'application', 'database', 'network', 'storage', 'service' (for configuration_items)"
                                },
                                "environment": {
                                    "type": "string",
                                    "description": "Environment: 'production', 'staging', 'development', 'testing' (for configuration_items)"
                                },
                                "location": {
                                    "type": "string",
                                    "description": "Physical or logical location (for configuration_items)"
                                },
                                "operational_status": {
                                    "type": "string",
                                    "description": "Operational status: 'operational', 'degraded', 'down', 'maintenance' (for configuration_items)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format (for configuration_items)"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverAudit(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover audit entities (audit_trails). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - audit_trails: Audit Trail records
        """
        if entity_type not in ["audit_trails"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'audit_trails'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "audit_id": entity_id})
            else:
                results.append({**entity_data, "audit_id": entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_audit",
                "description": "Discover audit entities (audit trails). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'audit_trails'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "audit_id": {
                                    "type": "string",
                                    "description": "Audit trail ID"
                                },
                                "reference_id": {
                                    "type": "string",
                                    "description": "ID of the record that was changed"
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "Type of record: 'user', 'client', 'vendor', 'subscription', 'sla', 'product', 'ci', 'incident', 'problem', 'escalation', 'bridge', 'change', 'rollback', 'work_order', 'communication', 'metric', 'report', 'rca'"
                                },
                                "action": {
                                    "type": "string",
                                    "description": "Action performed: 'create', 'update', 'delete'"
                                },
                                "user_id": {
                                    "type": "string",
                                    "description": "User ID who performed the action"
                                },
                                "field_name": {
                                    "type": "string",
                                    "description": "Name of the field that was changed"
                                },
                                "old_value": {
                                    "type": "string",
                                    "description": "Previous value before change"
                                },
                                "new_value": {
                                    "type": "string",
                                    "description": "New value after change"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverChangeControl(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover change control entities (change_requests, rollback_requests). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - change_requests: Change Request records
        - rollback_requests: Rollback Request records
        """
        if entity_type not in ["change_requests", "rollback_requests"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'change_requests' or 'rollback_requests'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    # Add appropriate ID field based on entity type
                    if entity_type == "change_requests":
                        id_field = "change_id"
                    else:  # rollback_requests
                        id_field = "rollback_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "change_requests":
                    id_field = "change_id"
                else:  # rollback_requests
                    id_field = "rollback_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_change_control",
                "description": "Discover change control entities (change requests, rollback requests). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'change_requests' or 'rollback_requests'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "change_id": {
                                    "type": "string",
                                    "description": "Change request ID (for change_requests)"
                                },
                                "change_number": {
                                    "type": "string",
                                    "description": "Change request number, e.g., CHG0001234 (for change_requests)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "title": {
                                    "type": "string",
                                    "description": "Change/rollback title"
                                },
                                "description": {
                                    "type": "string",
                                    "description": "Change description (for change_requests)"
                                },
                                "change_type": {
                                    "type": "string",
                                    "description": "Type of change: 'standard', 'normal', 'emergency' (for change_requests)"
                                },
                                "risk_level": {
                                    "type": "string",
                                    "description": "Risk level of change: 'low', 'medium', 'high', 'critical' (for change_requests)"
                                },
                                "requested_by": {
                                    "type": "string",
                                    "description": "User ID who requested the change/rollback"
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User ID who approved the change (for change_requests)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the change/rollback"
                                },
                                "implementation_date": {
                                    "type": "string",
                                    "description": "Implementation date in YYYY-MM-DD format (for change_requests)"
                                },
                                "rollback_id": {
                                    "type": "string",
                                    "description": "Rollback request ID (for rollback_requests)"
                                },
                                "rollback_number": {
                                    "type": "string",
                                    "description": "Rollback request number, e.g., RBK0001234 (for rollback_requests)"
                                },
                                "rollback_reason": {
                                    "type": "string",
                                    "description": "Reason for rollback (for rollback_requests)"
                                },
                                "executed_at": {
                                    "type": "string",
                                    "description": "Execution timestamp in YYYY-MM-DD format (for rollback_requests)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format (for change_requests)"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverContracts(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover contract entities (subscriptions, sla_agreements). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - subscriptions: Subscription records
        - sla_agreements: SLA Agreement records
        """
        if entity_type not in ["subscriptions", "sla_agreements"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'subscriptions' or 'sla_agreements'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    # Add appropriate ID field based on entity type
                    if entity_type == "subscriptions":
                        id_field = "subscription_id"
                    else:  # sla_agreements
                        id_field = "sla_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "subscriptions":
                    id_field = "subscription_id"
                else:  # sla_agreements
                    id_field = "sla_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_contracts",
                "description": "Discover contract entities (subscriptions, SLA agreements). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'subscriptions' or 'sla_agreements'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "subscription_id": {
                                    "type": "string",
                                    "description": "Subscription ID (for subscriptions)"
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "Client ID (for subscriptions)"
                                },
                                "tier": {
                                    "type": "string",
                                    "description": "Subscription tier: 'premium', 'standard', 'basic' (for subscriptions)"
                                },
                                "start_date": {
                                    "type": "string",
                                    "description": "Start date in YYYY-MM-DD format (for subscriptions)"
                                },
                                "end_date": {
                                    "type": "string",
                                    "description": "End date in YYYY-MM-DD format (for subscriptions)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status: 'active', 'expired', 'cancelled' (for subscriptions)"
                                },
                                "sla_id": {
                                    "type": "string",
                                    "description": "SLA agreement ID (for sla_agreements)"
                                },
                                "severity_level": {
                                    "type": "string",
                                    "description": "Severity level: 'P1', 'P2', 'P3', 'P4' (for sla_agreements)"
                                },
                                "response_time_minutes": {
                                    "type": "integer",
                                    "description": "Response time in minutes (for sla_agreements)"
                                },
                                "resolution_time_minutes": {
                                    "type": "integer",
                                    "description": "Resolution time in minutes (for sla_agreements)"
                                },
                                "availability_guarantee": {
                                    "type": "number",
                                    "description": "Availability guarantee percentage, e.g., 99.9 (for sla_agreements)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User ID who created the SLA (for sla_agreements)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format (for subscriptions)"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverCoordination(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover coordination entities (escalations, bridges, bridge_participants). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - escalations: Escalation records
        - bridges: Bridge records
        - bridge_participants: Bridge Participant records
        """
        if entity_type not in ["escalations", "bridges", "bridge_participants"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'escalations', 'bridges', or 'bridge_participants'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    # Add appropriate ID field based on entity type
                    if entity_type == "escalations":
                        id_field = "escalation_id"
                    elif entity_type == "bridges":
                        id_field = "bridge_id"
                    else:  # bridge_participants
                        id_field = "participant_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "escalations":
                    id_field = "escalation_id"
                elif entity_type == "bridges":
                    id_field = "bridge_id"
                else:  # bridge_participants
                    id_field = "participant_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_coordination",
                "description": "Discover coordination entities (escalations, bridges, bridge participants). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'escalations', 'bridges', or 'bridge_participants'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "escalation_id": {
                                    "type": "string",
                                    "description": "Escalation ID (for escalations)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "escalated_from": {
                                    "type": "string",
                                    "description": "User ID who requested escalation (for escalations)"
                                },
                                "escalated_to": {
                                    "type": "string",
                                    "description": "User ID receiving escalation (for escalations)"
                                },
                                "escalation_level": {
                                    "type": "string",
                                    "description": "Escalation level: 'L1_to_L2', 'L2_to_L3', 'L3_to_management', 'management_to_executive' (for escalations)"
                                },
                                "escalation_reason": {
                                    "type": "string",
                                    "description": "Reason for escalation (for escalations)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the escalation or bridge"
                                },
                                "requested_at": {
                                    "type": "string",
                                    "description": "Request timestamp in YYYY-MM-DD format (for escalations)"
                                },
                                "responded_at": {
                                    "type": "string",
                                    "description": "Response timestamp in YYYY-MM-DD format (for escalations)"
                                },
                                "bridge_id": {
                                    "type": "string",
                                    "description": "Bridge ID"
                                },
                                "bridge_number": {
                                    "type": "string",
                                    "description": "Bridge number, e.g., BRG0001234 (for bridges)"
                                },
                                "bridge_type": {
                                    "type": "string",
                                    "description": "Bridge type: 'major_incident', 'coordination', 'technical' (for bridges)"
                                },
                                "bridge_host": {
                                    "type": "string",
                                    "description": "User ID hosting the bridge (for bridges)"
                                },
                                "start_time": {
                                    "type": "string",
                                    "description": "Start timestamp in YYYY-MM-DD format (for bridges)"
                                },
                                "end_time": {
                                    "type": "string",
                                    "description": "End timestamp in YYYY-MM-DD format (for bridges)"
                                },
                                "participant_id": {
                                    "type": "string",
                                    "description": "Participant ID (for bridge_participants)"
                                },
                                "user_id": {
                                    "type": "string",
                                    "description": "User ID of the participant (for bridge_participants)"
                                },
                                "role_in_bridge": {
                                    "type": "string",
                                    "description": "Role in bridge: 'host', 'technical_support', 'account_manager', 'vendor', 'executive' (for bridge_participants)"
                                },
                                "joined_at": {
                                    "type": "string",
                                    "description": "Join timestamp in YYYY-MM-DD format (for bridge_participants)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverImprovement(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover improvement entities (root_cause_analyses, post_incident_reviews). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - root_cause_analyses: Root Cause Analysis records
        - post_incident_reviews: Post Incident Review records
        """
        if entity_type not in ["root_cause_analyses", "post_incident_reviews"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'root_cause_analyses' or 'post_incident_reviews'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    # Add appropriate ID field based on entity type
                    if entity_type == "root_cause_analyses":
                        id_field = "rca_id"
                    else:  # post_incident_reviews
                        id_field = "review_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "root_cause_analyses":
                    id_field = "rca_id"
                else:  # post_incident_reviews
                    id_field = "review_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_improvement",
                "description": "Discover improvement entities (root cause analyses, post incident reviews). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'root_cause_analyses' or 'post_incident_reviews'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "rca_id": {
                                    "type": "string",
                                    "description": "Root cause analysis ID (for root_cause_analyses)"
                                },
                                "rca_number": {
                                    "type": "string",
                                    "description": "RCA number, e.g., RCA0001234 (for root_cause_analyses)"
                                },
                                "rca_title": {
                                    "type": "string",
                                    "description": "RCA title (for root_cause_analyses)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "User ID assigned to the RCA (for root_cause_analyses)"
                                },
                                "analysis_method": {
                                    "type": "string",
                                    "description": "Analysis method: '5_whys', 'fishbone', 'timeline', 'fault_tree', 'kepner_tregoe' (for root_cause_analyses)"
                                },
                                "root_cause_summary": {
                                    "type": "string",
                                    "description": "Summary of root cause findings (for root_cause_analyses)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of RCA or review"
                                },
                                "due_date": {
                                    "type": "string",
                                    "description": "Due date in YYYY-MM-DD format (for root_cause_analyses)"
                                },
                                "completed_at": {
                                    "type": "string",
                                    "description": "Completion timestamp in YYYY-MM-DD format (for root_cause_analyses)"
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User ID who approved the RCA (for root_cause_analyses)"
                                },
                                "review_id": {
                                    "type": "string",
                                    "description": "Post incident review ID (for post_incident_reviews)"
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "description": "Scheduled date in YYYY-MM-DD format (for post_incident_reviews)"
                                },
                                "facilitator": {
                                    "type": "string",
                                    "description": "User ID of facilitator (for post_incident_reviews)"
                                },
                                "review_notes": {
                                    "type": "string",
                                    "description": "Notes from the review (for post_incident_reviews)"
                                },
                                "lessons_learned": {
                                    "type": "string",
                                    "description": "Lessons learned (for post_incident_reviews)"
                                },
                                "action_items": {
                                    "type": "string",
                                    "description": "Action items from the review (for post_incident_reviews)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format (for root_cause_analyses)"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverIncidentTracking(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover incident tracking entities (incidents, problem_tickets, work_notes, attachments, incident_reports, work_orders). 
        The entity to discover is decided by entity_type. Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - incidents: Incident records
        - problem_tickets: Problem Ticket records
        - work_notes: Work Note records
        - attachments: Attachment records
        - incident_reports: Incident Report records
        - work_orders: Work Order records
        """
        if entity_type not in ["incidents", "problem_tickets", "work_notes", "attachments", "incident_reports", "work_orders"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be one of: 'incidents', 'problem_tickets', 'work_notes', 'attachments', 'incident_reports', 'work_orders'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    # Add appropriate ID field based on entity type
                    if entity_type == "incidents":
                        id_field = "incident_id"
                    elif entity_type == "problem_tickets":
                        id_field = "problem_id"
                    elif entity_type == "work_notes":
                        id_field = "note_id"
                    elif entity_type == "attachments":
                        id_field = "attachment_id"
                    elif entity_type == "incident_reports":
                        id_field = "report_id"
                    else:  # work_orders
                        id_field = "work_order_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "incidents":
                    id_field = "incident_id"
                elif entity_type == "problem_tickets":
                    id_field = "problem_id"
                elif entity_type == "work_notes":
                    id_field = "note_id"
                elif entity_type == "attachments":
                    id_field = "attachment_id"
                elif entity_type == "incident_reports":
                    id_field = "report_id"
                else:  # work_orders
                    id_field = "work_order_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_incident_tracking",
                "description": "Discover incident tracking entities (incidents, problem tickets, work notes, attachments, incident reports, work orders). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'incidents', 'problem_tickets', 'work_notes', 'attachments', 'incident_reports', or 'work_orders'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Incident ID"
                                },
                                "problem_id": {
                                    "type": "string",
                                    "description": "Problem ticket ID"
                                },
                                "incident_number": {
                                    "type": "string",
                                    "description": "Incident number, e.g., INC0012345 (for incidents)"
                                },
                                "problem_number": {
                                    "type": "string",
                                    "description": "Problem number, e.g., PRB0001234 (for problem_tickets)"
                                },
                                "title": {
                                    "type": "string",
                                    "description": "Title of the incident, problem, or work order"
                                },
                                "description": {
                                    "type": "string",
                                    "description": "Description text"
                                },
                                "category": {
                                    "type": "string",
                                    "description": "Category: 'inquiry/help', 'software', 'hardware', 'Network', 'Database' (for incidents)"
                                },
                                "client_id": {
                                    "type": "string",
                                    "description": "Client ID"
                                },
                                "affected_ci_id": {
                                    "type": "string",
                                    "description": "Affected Configuration Item ID (for incidents)"
                                },
                                "severity": {
                                    "type": "string",
                                    "description": "Severity level: 'P1', 'P2', 'P3', 'P4' (for incidents)"
                                },
                                "impact": {
                                    "type": "string",
                                    "description": "Impact level: 'critical', 'high', 'medium', 'low' (for incidents)"
                                },
                                "urgency": {
                                    "type": "string",
                                    "description": "Urgency level: 'critical', 'high', 'medium', 'low' (for incidents)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the entity"
                                },
                                "reported_by": {
                                    "type": "string",
                                    "description": "User ID who reported the incident or problem"
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "User ID assigned to the incident or work order"
                                },
                                "detection_time": {
                                    "type": "string",
                                    "description": "Detection timestamp in YYYY-MM-DD format (for incidents)"
                                },
                                "acknowledged_at": {
                                    "type": "string",
                                    "description": "Acknowledgement timestamp in YYYY-MM-DD format (for incidents)"
                                },
                                "resolved_at": {
                                    "type": "string",
                                    "description": "Resolution timestamp in YYYY-MM-DD format (for incidents)"
                                },
                                "closed_at": {
                                    "type": "string",
                                    "description": "Closure timestamp in YYYY-MM-DD format (for incidents)"
                                },
                                "note_id": {
                                    "type": "string",
                                    "description": "Work note ID (for work_notes)"
                                },
                                "note_text": {
                                    "type": "string",
                                    "description": "Work note text content (for work_notes)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User ID who created the note (for work_notes)"
                                },
                                "attachment_id": {
                                    "type": "string",
                                    "description": "Attachment ID (for attachments)"
                                },
                                "reference_id": {
                                    "type": "string",
                                    "description": "Reference ID of the parent record (for attachments)"
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "Type of parent record: 'incident', 'change', 'rca', 'report', 'pir', 'communication', 'work_order', 'problem' (for attachments)"
                                },
                                "file_name": {
                                    "type": "string",
                                    "description": "File name (for attachments)"
                                },
                                "file_url": {
                                    "type": "string",
                                    "description": "File URL (for attachments)"
                                },
                                "file_type": {
                                    "type": "string",
                                    "description": "File type (for attachments)"
                                },
                                "file_size_bytes": {
                                    "type": "integer",
                                    "description": "File size in bytes (for attachments)"
                                },
                                "uploaded_by": {
                                    "type": "string",
                                    "description": "User ID who uploaded the file (for attachments)"
                                },
                                "uploaded_at": {
                                    "type": "string",
                                    "description": "Upload timestamp in YYYY-MM-DD format (for attachments)"
                                },
                                "report_id": {
                                    "type": "string",
                                    "description": "Report ID (for incident_reports)"
                                },
                                "report_number": {
                                    "type": "string",
                                    "description": "Report number, e.g., RPT0001234 (for incident_reports)"
                                },
                                "report_title": {
                                    "type": "string",
                                    "description": "Report title (for incident_reports)"
                                },
                                "report_type": {
                                    "type": "string",
                                    "description": "Report type: 'post_incident_review', 'client_impact', 'compliance' (for incident_reports)"
                                },
                                "report_content": {
                                    "type": "string",
                                    "description": "Report content (for incident_reports)"
                                },
                                "generated_by": {
                                    "type": "string",
                                    "description": "User ID who generated the report (for incident_reports)"
                                },
                                "generation_date": {
                                    "type": "string",
                                    "description": "Generation timestamp in YYYY-MM-DD format (for incident_reports)"
                                },
                                "report_status": {
                                    "type": "string",
                                    "description": "Report status: 'draft', 'completed', 'approved', 'archived' (for incident_reports)"
                                },
                                "work_order_id": {
                                    "type": "string",
                                    "description": "Work order ID (for work_orders)"
                                },
                                "work_order_number": {
                                    "type": "string",
                                    "description": "Work order number, e.g., WO0001234 (for work_orders)"
                                },
                                "change_id": {
                                    "type": "string",
                                    "description": "Associated change request ID (for work_orders)"
                                },
                                "scheduled_date": {
                                    "type": "string",
                                    "description": "Scheduled date in YYYY-MM-DD format (for work_orders)"
                                },
                                "completed_at": {
                                    "type": "string",
                                    "description": "Completion timestamp in YYYY-MM-DD format (for work_orders)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverParties(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover party entities (clients, vendors, users). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - clients: Client records
        - vendors: Vendor records
        - users: User records
        """
        if entity_type not in ["clients", "vendors", "users"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'clients', 'vendors', or 'users'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    # Add appropriate ID field based on entity type
                    if entity_type == "clients":
                        id_field = "client_id"
                    elif entity_type == "vendors":
                        id_field = "vendor_id"
                    else:  # users
                        id_field = "user_id"
                        # Remove role field from user data
                        entity_data = {k: v for k, v in entity_data.items() if k != "role"}
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "clients":
                    id_field = "client_id"
                elif entity_type == "vendors":
                    id_field = "vendor_id"
                else:  # users
                    id_field = "user_id"
                    # Remove role field from user data
                    entity_data = {k: v for k, v in entity_data.items() if k != "role"}
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_parties",
                "description": "Discover party entities (clients, vendors, users). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'clients', 'vendors', or 'users'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "client_id": {
                                    "type": "string",
                                    "description": "Client ID (for clients)"
                                },
                                "client_name": {
                                    "type": "string",
                                    "description": "Client name (for clients)"
                                },
                                "registration_number": {
                                    "type": "string",
                                    "description": "Registration number (for clients)"
                                },
                                "company_type": {
                                    "type": "string",
                                    "description": "Company type: 'enterprise', 'mid_market', 'smb', 'startup' (for clients)"
                                },
                                "address": {
                                    "type": "string",
                                    "description": "Client address (for clients)"
                                },
                                "contact_phone": {
                                    "type": "string",
                                    "description": "Contact phone number"
                                },
                                "contact_email": {
                                    "type": "string",
                                    "description": "Contact email address"
                                },
                                "support_coverage": {
                                    "type": "string",
                                    "description": "Support coverage: '24x7', 'business_hours', 'on_call' (for clients)"
                                },
                                "preferred_communication": {
                                    "type": "string",
                                    "description": "Preferred communication method: 'email', 'portal', 'phone', 'slack' (for clients)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the entity"
                                },
                                "vendor_id": {
                                    "type": "string",
                                    "description": "Vendor ID (for vendors)"
                                },
                                "vendor_name": {
                                    "type": "string",
                                    "description": "Vendor name (for vendors)"
                                },
                                "user_id": {
                                    "type": "string",
                                    "description": "User ID (for users)"
                                },
                                "first_name": {
                                    "type": "string",
                                    "description": "User first name (for users)"
                                },
                                "last_name": {
                                    "type": "string",
                                    "description": "User last name (for users)"
                                },
                                "email": {
                                    "type": "string",
                                    "description": "User email address (for users)"
                                },
                                "timezone": {
                                    "type": "string",
                                    "description": "User timezone (for users)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                },
                                "updated_at": {
                                    "type": "string",
                                    "description": "Update timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverPerformance(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover performance entities (performance_metrics). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - performance_metrics: Performance Metric records
        """
        if entity_type not in ["performance_metrics"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'performance_metrics'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    results.append({**entity_data, "metric_id": entity_id})
            else:
                results.append({**entity_data, "metric_id": entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_performance",
                "description": "Discover performance entities (performance metrics). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'performance_metrics'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "metric_id": {
                                    "type": "string",
                                    "description": "Performance metric ID"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "metric_type": {
                                    "type": "string",
                                    "description": "Type of metric: 'MTTA', 'MTTD', 'MTTR', 'MTTM', 'FTR'"
                                },
                                "calculated_value_minutes": {
                                    "type": "integer",
                                    "description": "Calculated value in minutes"
                                },
                                "sla_target_minutes": {
                                    "type": "integer",
                                    "description": "SLA target in minutes"
                                },
                                "recorded_by": {
                                    "type": "string",
                                    "description": "User ID who recorded the metric"
                                },
                                "recorded_date": {
                                    "type": "string",
                                    "description": "Recording timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
from typing import Any, Dict, List
from tau_bench.envs.tool import Tool


class DiscoverWorkflows(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, filters: Dict[str, Any] = None) -> str:
        """
        Discover workflow entities (communications, approval_requests). The entity to discover is decided by entity_type.
        Optionally, filters can be applied to narrow down the search results.
        
        Supported entities:
        - communications: Communication records
        - approval_requests: Approval Request records
        """
        if entity_type not in ["communications", "approval_requests"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'communications' or 'approval_requests'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        results = []
        entities = data.get(entity_type, {})
        
        for entity_id, entity_data in entities.items():
            if filters:
                match = True
                for filter_key, filter_value in filters.items():
                    entity_value = entity_data.get(filter_key)
                    if entity_value != filter_value:
                        match = False
                        break
                if match:
                    # Add appropriate ID field based on entity type
                    if entity_type == "communications":
                        id_field = "communication_id"
                    else:  # approval_requests
                        id_field = "approval_id"
                    results.append({**entity_data, id_field: entity_id})
            else:
                if entity_type == "communications":
                    id_field = "communication_id"
                else:  # approval_requests
                    id_field = "approval_id"
                results.append({**entity_data, id_field: entity_id})
        
        return json.dumps({
            "success": True,
            "entity_type": entity_type,
            "count": len(results),
            "results": results
        })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "discover_workflows",
                "description": "Discover workflow entities (communications, approval requests). The entity to discover is decided by entity_type. Optional filters can be applied to narrow down the search results.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to discover: 'communications' or 'approval_requests'"
                        },
                        "filters": {
                            "type": "object",
                            "description": "Optional filters to narrow down search results. Only exact matches are supported (AND logic for multiple filters).",
                            "properties": {
                                "communication_id": {
                                    "type": "string",
                                    "description": "Communication ID (for communications)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Associated incident ID"
                                },
                                "communication_type": {
                                    "type": "string",
                                    "description": "Type of communication: 'status_update', 'resolution_notice', 'escalation_notice', 'bridge_invitation' (for communications)"
                                },
                                "recipient_type": {
                                    "type": "string",
                                    "description": "Type of recipient: 'client', 'internal', 'vendor', 'executive' (for communications)"
                                },
                                "sender": {
                                    "type": "string",
                                    "description": "User ID of sender (for communications)"
                                },
                                "recipient": {
                                    "type": "string",
                                    "description": "User ID of recipient (for communications)"
                                },
                                "delivery_method": {
                                    "type": "string",
                                    "description": "Delivery method: 'email', 'portal', 'sms', 'phone' (for communications)"
                                },
                                "message_content": {
                                    "type": "string",
                                    "description": "Message content (for communications)"
                                },
                                "delivery_status": {
                                    "type": "string",
                                    "description": "Delivery status: 'pending', 'sent', 'delivered', 'failed' (for communications)"
                                },
                                "sent_at": {
                                    "type": "string",
                                    "description": "Sent timestamp in YYYY-MM-DD format (for communications)"
                                },
                                "approval_id": {
                                    "type": "string",
                                    "description": "Approval request ID (for approval_requests)"
                                },
                                "reference_id": {
                                    "type": "string",
                                    "description": "ID of the record requiring approval (for approval_requests)"
                                },
                                "reference_type": {
                                    "type": "string",
                                    "description": "Type of record requiring approval: 'escalation', 'bridge', 'change', 'rollback', 'incident_closure', 'rca' (for approval_requests)"
                                },
                                "requested_by": {
                                    "type": "string",
                                    "description": "User ID who requested approval (for approval_requests)"
                                },
                                "requested_action": {
                                    "type": "string",
                                    "description": "Action being requested (for approval_requests)"
                                },
                                "approver": {
                                    "type": "string",
                                    "description": "User ID of approver (for approval_requests)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Approval status: 'pending', 'approved', 'denied' (for approval_requests)"
                                },
                                "requested_at": {
                                    "type": "string",
                                    "description": "Request timestamp in YYYY-MM-DD format (for approval_requests)"
                                },
                                "responded_at": {
                                    "type": "string",
                                    "description": "Response timestamp in YYYY-MM-DD format (for approval_requests)"
                                },
                                "created_at": {
                                    "type": "string",
                                    "description": "Creation timestamp in YYYY-MM-DD format"
                                }
                            }
                        }
                    },
                    "required": ["entity_type"]
                }
            }
        }
import json
import os
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class LogAuditRecords(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        audit_id: Optional[str] = None,
        audit_data: Optional[Dict[str, Any]] = None,
    ) -> str:
        def generate_id(table: Dict[str, Any]) -> str:
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        # Resolve correct data directory dynamically
        TOOL_DIR = os.path.dirname(os.path.abspath(__file__))
        ENV_DIR = os.path.dirname(TOOL_DIR)
        DATA_DIR = os.path.join(ENV_DIR, "data")
        AUDIT_FP = os.path.join(DATA_DIR, "audit_trails.json")

        def ensure_dirs() -> None:
            os.makedirs(DATA_DIR, exist_ok=True)

        def load_audit_trails() -> Dict[str, Any]:
            if os.path.exists(AUDIT_FP):
                try:
                    with open(AUDIT_FP, "r") as f:
                        return json.load(f)
                except Exception:
                    return {}
            return {}

        def save_audit_trails(audit_dict: Dict[str, Any]) -> None:
            ensure_dirs()
            with open(AUDIT_FP, "w") as f:
                json.dump(audit_dict, f, indent=2)

        timestamp = "2025-11-01T00:00:00"
        audit_trails = data.setdefault("audit_trails", {})
        users = data.setdefault("users", {})

        if not audit_trails:
            loaded = load_audit_trails()
            if loaded:
                audit_trails.update(loaded)

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        # ---------- CREATE ----------
        if action == "create":
            if not audit_data:
                return json.dumps({
                    "success": False,
                    "error": "audit_data is required for create action"
                })

            required_fields = [
                "reference_id", "reference_type", "action",
                "user_id", "field_name", "old_value", "new_value"
            ]
            missing_fields = [f for f in required_fields if f not in audit_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })

            user_id = str(audit_data["user_id"])
            if user_id not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User with ID '{user_id}' not found"
                })

            new_audit_id = generate_id(audit_trails)
            new_entry = {
                "audit_id": new_audit_id,
                "reference_id": str(audit_data["reference_id"]),
                "reference_type": audit_data["reference_type"],
                "action": audit_data["action"],
                "user_id": user_id,
                "field_name": audit_data["field_name"],
                "old_value": audit_data["old_value"],
                "new_value": audit_data["new_value"],
                "created_at": timestamp
            }

            audit_trails[new_audit_id] = new_entry
            save_audit_trails(audit_trails)
            return json.dumps(new_entry)

        # ---------- UPDATE ----------
        if action == "update":
            if not audit_id:
                return json.dumps({
                    "success": False,
                    "error": "audit_id is required for update action"
                })

            if audit_id not in audit_trails:
                return json.dumps({
                    "success": False,
                    "error": f"Audit record with ID '{audit_id}' not found"
                })

            if not audit_data:
                return json.dumps({
                    "success": False,
                    "error": "audit_data is required for update action"
                })

            updated_audit = audit_trails[audit_id].copy()
            for key, value in audit_data.items():
                if key in updated_audit and value is not None:
                    updated_audit[key] = value

            updated_audit["created_at"] = timestamp
            audit_trails[audit_id] = updated_audit
            save_audit_trails(audit_trails)
            return json.dumps(updated_audit)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "log_audit_records",
                "description": (
                    "Create or update audit trail records. "
                    "This API reads from and writes to data/audit_trails.json, maintaining a record of all field changes. "
                    "Each record tracks reference_id, reference_type, action, user_id, field_name, old_value, new_value, and timestamp."
                ),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": (
                                "Action to perform:\n"
                                "- 'create': Add a new audit entry (requires audit_data)\n"
                                "- 'update': Modify an existing entry (requires audit_id and audit_data)"
                            ),
                            "enum": ["create", "update"]
                        },
                        "audit_id": {
                            "type": "string",
                            "description": "Unique audit record ID (required for update action only)"
                        },
                        "audit_data": {
                            "type": "object",
                            "description": (
                                "Audit record data object containing reference details and field changes.\n\n"
                                "For 'create': requires reference_id, reference_type, action, user_id, field_name, old_value, new_value.\n"
                                "For 'update': any of these fields can be modified.\n\n"
                                "Example Create:\n"
                                "{\n"
                                "  \"reference_id\": \"56\",\n"
                                "  \"reference_type\": \"escalation\",\n"
                                "  \"action\": \"create\",\n"
                                "  \"user_id\": \"15\",\n"
                                "  \"field_name\": \"priority\",\n"
                                "  \"old_value\": \"building\",\n"
                                "  \"new_value\": \"star\"\n"
                                "}\n\n"
                                "Example Update:\n"
                                "{ \"new_value\": \"critical\" }"
                            ),
                            "properties": {
                                "reference_id": {"type": "string"},
                                "reference_type": {"type": "string"},
                                "action": {"type": "string"},
                                "user_id": {"type": "string"},
                                "field_name": {"type": "string"},
                                "old_value": {"type": "string"},
                                "new_value": {"type": "string"}
                            }
                        }
                    },
                    "required": ["action"]
                }
            }
        }
import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageApprovalRequests(Tool):
    """
    Create and update approval requests for various items requiring approval.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        approval_id: Optional[str] = None,
        reference_id: Optional[str] = None,
        reference_type: Optional[str] = None,
        requested_by: Optional[str] = None,
        requested_action: Optional[str] = None,
        approver: Optional[str] = None,
        status: Optional[str] = None,
        approval_notes: Optional[str] = None
    ) -> str:
        """
        Create or update approval request records.

        Actions:
        - create: Create new approval request (requires reference_id, reference_type, requested_by, requested_action, approver)
        - update: Update existing approval request (requires approval_id and at least one field to update)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        def generate_approval_number(approval_id: str) -> str:
            """Generate a formatted approval request number."""
            return f"APR{approval_id.zfill(8)}"

        timestamp = "2025-10-01T12:00:00"
        approvals = data.get("approval_requests", {})
        users = data.get("users", {})

        valid_reference_types = ["escalation", "bridge", "change", "rollback", "incident_closure", "rca"]
        valid_statuses = ["pending", "approved", "denied", "cancelled"]

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "update" and not approval_id:
            return json.dumps({
                "success": False,
                "error": "approval_id is required for update action"
            })

        if action == "create":
            if not all([reference_id, reference_type, requested_by, requested_action, approver]):
                return json.dumps({
                    "success": False,
                    "error": "reference_id, reference_type, requested_by, requested_action, and approver are required for create action"
                })

            # Validate users exist and are active
            for user_id in [requested_by, approver]:
                if user_id not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {user_id} not found"
                    })
                if users[user_id]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {user_id} is not active"
                    })

            if reference_type not in valid_reference_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid reference_type. Must be one of: {', '.join(valid_reference_types)}"
                })

            new_id = generate_id(approvals)
            approval_number = generate_approval_number(new_id)
            new_approval = {
                "approval_id": new_id,
                "approval_number": approval_number,
                "reference_id": reference_id,
                "reference_type": reference_type,
                "requested_by": requested_by,
                "requested_action": requested_action,
                "approver": approver,
                "status": "pending",
                "approval_notes": approval_notes.strip() if approval_notes else None,
                "requested_at": timestamp,
                "responded_at": None,
                "created_at": timestamp,
                "updated_at": timestamp,
                "last_modified_by": requested_by,
                "version": 1,
                "history": [{
                    "timestamp": timestamp,
                    "action": "created",
                    "user_id": requested_by,
                    "details": "Approval request created"
                }]
            }
            approvals[new_id] = new_approval

            return json.dumps({
                "success": True,
                "action": "create",
                "approval_id": new_id,
                "approval_number": approval_number,
                "approval_data": new_approval
            })

        if action == "update":
            if approval_id not in approvals:
                return json.dumps({
                    "success": False,
                    "error": f"Approval request with ID {approval_id} not found"
                })

            # Validate at least one field is being updated
            update_fields = [status, approval_notes]
            if all(v is None for v in update_fields):
                return json.dumps({
                    "success": False,
                    "error": "At least one field must be provided for update"
                })

            existing_approval = approvals[approval_id]

            history_entry = {
                "timestamp": timestamp,
                "action": "updated",
                "user_id": approver,
                "changes": []
            }

            if status is not None:
                if status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                history_entry["changes"].append({"field": "status", "old": existing_approval["status"], "new": status})
                existing_approval["status"] = status
                if status in ["approved", "denied"]:
                    existing_approval["responded_at"] = timestamp

            if approval_notes is not None:
                history_entry["changes"].append({"field": "approval_notes", "old": existing_approval["approval_notes"], "new": approval_notes.strip()})
                existing_approval["approval_notes"] = approval_notes.strip()

            existing_approval["updated_at"] = timestamp
            existing_approval["last_modified_by"] = approver
            existing_approval["version"] += 1
            existing_approval["history"].append(history_entry)

            return json.dumps({
                "success": True,
                "action": "update",
                "approval_id": approval_id,
                "approval_number": existing_approval["approval_number"],
                "approval_data": existing_approval
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns comprehensive information about the tool's capabilities, parameters, and data schema.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_approval_requests",
                "description": "Create/update approval requests for various items requiring approval. Actions: 'create' (requires reference_id, reference_type, requested_by, requested_action, approver; optional: approval_notes), 'update' (requires approval_id; optional: status, approval_notes).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "approval_id": {
                            "type": "string",
                            "description": "Required for update. ID of the approval request to update"
                        },
                        "reference_id": {
                            "type": "string",
                            "description": "Required for create. ID of the item needing approval"
                        },
                        "reference_type": {
                            "type": "string",
                            "description": "Type of item requiring approval: escalation, bridge, change, rollback, incident_closure, rca",
                            "enum": ["escalation", "bridge", "change", "rollback", "incident_closure", "rca"]
                        },
                        "requested_by": {
                            "type": "string",
                            "description": "Required for create. ID of the active user requesting approval"
                        },
                        "requested_action": {
                            "type": "string",
                            "description": "Required for create. Description of the action requiring approval"
                        },
                        "approver": {
                            "type": "string",
                            "description": "Required for create. ID of the active user who needs to approve"
                        },
                        "status": {
                            "type": "string",
                            "description": "Status of the approval request",
                            "enum": ["pending", "approved", "denied", "cancelled"]
                        },
                        "approval_notes": {
                            "type": "string",
                            "description": "Notes provided during approval/denial"
                        }
                    },
                    "required": ["action"]
                }
            }
        }import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageAssets(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_type: str,
        entity_data: Optional[Dict[str, Any]] = None,
        entity_id: Optional[str] = None
    ) -> str:
        """
        Create or update product and configuration item records.
        
        Actions:
        - create: Create new product or configuration item record (requires entity_data)
        - update: Update existing product or configuration item record (requires entity_id and entity_data)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if entity_type not in ["products", "configuration_items"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'products' or 'configuration_items'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        # ========== PRODUCTS ==========
        if entity_type == "products":
            products = data.get("products", {})
            
            if action == "create":
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for create action"
                    })
                
                # Validate required fields
                required_fields = ["product_name"]
                missing_fields = [field for field in required_fields if field not in entity_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Missing required fields: {', '.join(missing_fields)}"
                    })
                
                # Validate allowed fields
                allowed_fields = ["product_name", "product_code", "description", "status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate status enum
                if "status" in entity_data:
                    valid_status = ["active", "deprecated", "retired"]
                    if entity_data["status"] not in valid_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid status '{entity_data['status']}'. Must be one of: {', '.join(valid_status)}"
                        })
                
                # Check product_code uniqueness if provided
                if "product_code" in entity_data and entity_data["product_code"]:
                    for product in products.values():
                        if product.get("product_code") == entity_data["product_code"]:
                            return json.dumps({
                                "success": False,
                                "error": "Product code already exists"
                            })
                
                # Create new product
                new_id = str(generate_id(products))
                new_product = {
                    "product_id": new_id,
                    "product_name": entity_data["product_name"],
                    "product_code": entity_data.get("product_code"),
                    "description": entity_data.get("description"),
                    "status": entity_data.get("status", "active"),
                    "created_at": timestamp
                }
                products[new_id] = new_product
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": "products",
                    "product_id": new_id,
                    "product_data": new_product
                })
            
            elif action == "update":
                if not entity_id:
                    return json.dumps({
                        "success": False,
                        "error": "entity_id is required for update action"
                    })
                
                if entity_id not in products:
                    return json.dumps({
                        "success": False,
                        "error": f"Product {entity_id} not found"
                    })
                
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for update action"
                    })
                
                # Validate allowed fields
                allowed_fields = ["product_name", "product_code", "description", "status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate status enum if provided
                if "status" in entity_data:
                    valid_status = ["active", "deprecated", "retired"]
                    if entity_data["status"] not in valid_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                        })
                
                # Check product_code uniqueness if being updated
                if "product_code" in entity_data and entity_data["product_code"]:
                    for pid, product in products.items():
                        if pid != entity_id and product.get("product_code") == entity_data["product_code"]:
                            return json.dumps({
                                "success": False,
                                "error": "New product_code already exists"
                            })
                
                # Update product
                updated_product = products[entity_id].copy()
                for key, value in entity_data.items():
                    updated_product[key] = value
                products[entity_id] = updated_product
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "entity_type": "products",
                    "product_id": entity_id,
                    "product_data": updated_product
                })
        
        # ========== CONFIGURATION ITEMS ==========
        elif entity_type == "configuration_items":
            configuration_items = data.get("configuration_items", {})
            products = data.get("products", {})
            
            if action == "create":
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for create action"
                    })
                
                # Validate required fields
                required_fields = ["ci_name", "product_id", "ci_type", "environment"]
                missing_fields = [field for field in required_fields if field not in entity_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Missing required fields: {', '.join(missing_fields)}"
                    })
                
                # Validate allowed fields
                allowed_fields = ["ci_name", "product_id", "ci_type", "environment", "location", "operational_status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate ci_type enum
                valid_ci_types = ["server", "application", "database", "network", "storage", "service"]
                if entity_data["ci_type"] not in valid_ci_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid ci_type '{entity_data['ci_type']}'. Must be one of: {', '.join(valid_ci_types)}"
                    })
                
                # Validate environment enum
                valid_environments = ["production", "staging", "development", "testing"]
                if entity_data["environment"] not in valid_environments:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid environment '{entity_data['environment']}'. Must be one of: {', '.join(valid_environments)}"
                    })
                
                # Validate operational_status enum if provided
                if "operational_status" in entity_data:
                    valid_operational_status = ["operational", "degraded", "down", "maintenance"]
                    if entity_data["operational_status"] not in valid_operational_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid operational_status '{entity_data['operational_status']}'. Must be one of: {', '.join(valid_operational_status)}"
                        })
                
                # Validate product_id exists
                if entity_data["product_id"] not in products:
                    return json.dumps({
                        "success": False,
                        "error": "Product not found"
                    })
                
                # Check ci_name uniqueness per product
                for ci in configuration_items.values():
                    if ci.get("ci_name") == entity_data["ci_name"] and ci.get("product_id") == entity_data["product_id"]:
                        return json.dumps({
                            "success": False,
                            "error": "CI name already exists for this product"
                        })
                
                # Create new configuration item
                new_id = str(generate_id(configuration_items))
                new_ci = {
                    "ci_id": new_id,
                    "ci_name": entity_data["ci_name"],
                    "product_id": entity_data["product_id"],
                    "ci_type": entity_data["ci_type"],
                    "environment": entity_data["environment"],
                    "location": entity_data.get("location"),
                    "operational_status": entity_data.get("operational_status", "operational"),
                    "created_at": timestamp,
                    "updated_at": timestamp
                }
                configuration_items[new_id] = new_ci
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": "configuration_items",
                    "ci_id": new_id,
                    "ci_data": new_ci
                })
            
            elif action == "update":
                if not entity_id:
                    return json.dumps({
                        "success": False,
                        "error": "entity_id is required for update action"
                    })
                
                if entity_id not in configuration_items:
                    return json.dumps({
                        "success": False,
                        "error": f"Configuration item {entity_id} not found"
                    })
                
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for update action"
                    })
                
                # Validate allowed fields
                allowed_fields = ["ci_name", "product_id", "ci_type", "environment", "location", "operational_status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate ci_type enum if provided
                if "ci_type" in entity_data:
                    valid_ci_types = ["server", "application", "database", "network", "storage", "service"]
                    if entity_data["ci_type"] not in valid_ci_types:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid ci_type. Must be one of: {', '.join(valid_ci_types)}"
                        })
                
                # Validate environment enum if provided
                if "environment" in entity_data:
                    valid_environments = ["production", "staging", "development", "testing"]
                    if entity_data["environment"] not in valid_environments:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid environment. Must be one of: {', '.join(valid_environments)}"
                        })
                
                # Validate operational_status enum if provided
                if "operational_status" in entity_data:
                    valid_operational_status = ["operational", "degraded", "down", "maintenance"]
                    if entity_data["operational_status"] not in valid_operational_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid operational_status. Must be one of: {', '.join(valid_operational_status)}"
                        })
                
                # Validate product_id if being updated
                if "product_id" in entity_data:
                    if entity_data["product_id"] not in products:
                        return json.dumps({
                            "success": False,
                            "error": "Product not found"
                        })
                
                # Check ci_name uniqueness per product if being updated
                current_ci = configuration_items[entity_id]
                new_ci_name = entity_data.get("ci_name", current_ci.get("ci_name"))
                new_product_id = entity_data.get("product_id", current_ci.get("product_id"))
                
                if "ci_name" in entity_data or "product_id" in entity_data:
                    for cid, ci in configuration_items.items():
                        if cid != entity_id and ci.get("ci_name") == new_ci_name and ci.get("product_id") == new_product_id:
                            return json.dumps({
                                "success": False,
                                "error": "New CI name already exists for this product"
                            })
                
                # Update configuration item
                updated_ci = configuration_items[entity_id].copy()
                for key, value in entity_data.items():
                    updated_ci[key] = value
                updated_ci["updated_at"] = timestamp
                configuration_items[entity_id] = updated_ci
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "entity_type": "configuration_items",
                    "ci_id": entity_id,
                    "ci_data": updated_ci
                })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_assets",
                "description": "Create or update product and configuration item records in the incident management system. For creation, establishes new product or configuration item records with comprehensive validation. For updates, modifies existing records while maintaining data integrity. Validates product codes, CI types, environments, and operational status values according to system requirements.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new record, 'update' to modify existing record",
                            "enum": ["create", "update"]
                        },
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to manage: 'products' or 'configuration_items'",
                            "enum": ["products", "configuration_items"]
                        },
                        "entity_data": {
                            "type": "object",
                            "description": "Entity data object. For products create: requires product_name, with optional product_code (must be unique), description, status ('active', 'deprecated', 'retired'). For configuration_items create: requires ci_name, product_id, ci_type ('server', 'application', 'database', 'network', 'storage', 'service'), environment ('production', 'staging', 'development', 'testing'), with optional location, operational_status ('operational', 'degraded', 'down', 'maintenance'). For update: includes fields to change. SYNTAX: {\"key\": \"value\"}"
                        },
                        "entity_id": {
                            "type": "string",
                            "description": "Unique identifier of the entity record (product_id for products, ci_id for configuration_items). Required for update action only."
                        }
                    },
                    "required": ["action", "entity_type"]
                }
            }
        }
# manage_attachments.py
import json
import os
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageAttachments(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        attachment_id: Optional[str] = None,
        attachment_data: Optional[Dict[str, Any]] = None,
    ) -> str:
        def generate_id(table: Dict[str, Any]) -> str:
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        TOOL_DIR = os.path.dirname(os.path.abspath(__file__))
        PROJECT_ROOT = os.path.dirname(TOOL_DIR)
        DATA_DIR = os.path.join(PROJECT_ROOT, "data")
        ATTACHMENTS_FP = os.path.join(DATA_DIR, "attachments.json")

        def ensure_dirs() -> None:
            os.makedirs(DATA_DIR, exist_ok=True)

        def load_attachments() -> Dict[str, Any]:
            if os.path.exists(ATTACHMENTS_FP):
                try:
                    with open(ATTACHMENTS_FP, "r") as f:
                        return json.load(f)
                except Exception:
                    return {}
            return {}

        def save_attachments(attachments_dict: Dict[str, Any]) -> None:
            ensure_dirs()
            with open(ATTACHMENTS_FP, "w") as f:
                json.dump(attachments_dict, f, indent=2)

        timestamp = "2025-11-01T00:00:00"
        attachments = data.setdefault("attachments", {})
        users = data.setdefault("users", {})
        incidents = data.setdefault("incidents", {})
        change_requests = data.setdefault("change_requests", {})
        root_cause_analyses = data.setdefault("root_cause_analyses", {})
        incident_reports = data.setdefault("incident_reports", {})
        post_incident_reviews = data.setdefault("post_incident_reviews", {})
        communications = data.setdefault("communications", {})
        work_orders = data.setdefault("work_orders", {})
        problem_tickets = data.setdefault("problem_tickets", {})

        if not attachments:
            loaded = load_attachments()
            if loaded:
                attachments.update(loaded)

        reference_tables = {
            "incident": incidents,
            "change": change_requests,
            "rca": root_cause_analyses,
            "report": incident_reports,
            "pir": post_incident_reviews,
            "communication": communications,
            "work_order": work_orders,
            "problem": problem_tickets
        }
        valid_reference_types = list(reference_tables.keys())

        if action not in ["create", "update"]:
            return json.dumps({"success": False, "error": f"Invalid action '{action}'. Must be 'create' or 'update'"})

        if action == "create":
            if not attachment_data:
                return json.dumps({"success": False, "error": "attachment_data is required for create action"})
            required_fields = ["reference_id", "reference_type", "file_name", "file_url", "uploaded_by"]
            missing_fields = [f for f in required_fields if f not in attachment_data]
            if missing_fields:
                return json.dumps({"success": False, "error": f"Missing required fields: {', '.join(missing_fields)}"})
            reference_type = attachment_data["reference_type"]
            if reference_type not in valid_reference_types:
                return json.dumps({"success": False, "error": f"Invalid reference_type. Must be one of: {', '.join(valid_reference_types)}"})
            reference_id = str(attachment_data["reference_id"])
            reference_table = reference_tables[reference_type]
            if reference_id not in reference_table:
                return json.dumps({"success": False, "error": f"Reference {reference_type} with ID '{reference_id}' not found"})
            uploaded_by = str(attachment_data["uploaded_by"])
            if uploaded_by not in users:
                return json.dumps({"success": False, "error": f"User with ID '{uploaded_by}' not found"})
            file_size_bytes = attachment_data.get("file_size_bytes")
            if file_size_bytes is not None:
                try:
                    file_size_bytes = int(file_size_bytes)
                    if file_size_bytes < 0:
                        raise ValueError
                except Exception:
                    return json.dumps({"success": False, "error": "file_size_bytes must be a non-negative integer"})
            new_attachment_id = generate_id(attachments)
            new_attachment = {
                "attachment_id": new_attachment_id,
                "reference_id": reference_id,
                "reference_type": reference_type,
                "file_name": attachment_data["file_name"],
                "file_url": attachment_data["file_url"],
                "file_type": attachment_data.get("file_type"),
                "file_size_bytes": file_size_bytes,
                "uploaded_by": uploaded_by,
                "uploaded_at": timestamp,
                "created_at": timestamp,
                "updated_at": timestamp
            }
            attachments[new_attachment_id] = new_attachment
            save_attachments(attachments)
            return json.dumps(new_attachment)

        if not attachment_id:
            return json.dumps({"success": False, "error": "attachment_id is required for update action"})
        if attachment_id not in attachments:
            return json.dumps({"success": False, "error": f"Attachment with ID '{attachment_id}' not found"})
        if not attachment_data:
            return json.dumps({"success": False, "error": "attachment_data is required for update action"})

        current_attachment = attachments[attachment_id]
        updated_attachment = current_attachment.copy()
        effective_reference_type = attachment_data.get("reference_type", current_attachment.get("reference_type"))
        effective_reference_id = str(attachment_data.get("reference_id", current_attachment.get("reference_id", "")))
        if effective_reference_type not in valid_reference_types:
            return json.dumps({"success": False, "error": f"Invalid reference_type. Must be one of: {', '.join(valid_reference_types)}"})
        ref_table = reference_tables[effective_reference_type]
        if effective_reference_id not in ref_table:
            return json.dumps({"success": False, "error": f"Reference {effective_reference_type} with ID '{effective_reference_id}' not found"})
        if "uploaded_by" in attachment_data:
            new_uploader = str(attachment_data["uploaded_by"])
            if new_uploader not in users:
                return json.dumps({"success": False, "error": f"User with ID '{new_uploader}' not found"})
        if "file_size_bytes" in attachment_data and attachment_data["file_size_bytes"] is not None:
            try:
                fs_int = int(attachment_data["file_size_bytes"])
                if fs_int < 0:
                    raise ValueError
                attachment_data["file_size_bytes"] = fs_int
            except Exception:
                return json.dumps({"success": False, "error": "file_size_bytes must be a non-negative integer"})
        allowed_fields = {"reference_id","reference_type","file_name","file_url","file_type","file_size_bytes","uploaded_by"}
        for key, value in attachment_data.items():
            if key not in allowed_fields:
                continue
            if key in {"reference_id", "uploaded_by"} and value is not None:
                updated_attachment[key] = str(value)
            else:
                updated_attachment[key] = value
        updated_attachment["reference_type"] = effective_reference_type
        updated_attachment["reference_id"] = effective_reference_id
        updated_attachment["updated_at"] = timestamp
        attachments[attachment_id] = updated_attachment
        save_attachments(attachments)
        return json.dumps(updated_attachment)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_attachments",
                "description": "Create or update attachment records with file persistence to data/attachments.json.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {"type": "string","enum": ["create", "update"]},
                        "attachment_id": {"type": "string"},
                        "attachment_data": {
                            "type": "object",
                            "properties": {
                                "reference_id": {"type": "string"},
                                "reference_type": {"type": "string"},
                                "file_name": {"type": "string"},
                                "file_url": {"type": "string"},
                                "file_type": {"type": "string"},
                                "file_size_bytes": {"type": "integer"},
                                "uploaded_by": {"type": "string"}
                            }
                        }
                    },
                    "required": ["action"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageChangeControl(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], entity_type: str, action: str, change_control_data: Dict[str, Any] = None, change_id: str = None, rollback_id: str = None) -> str:
        """
        Create or update change control records (change requests or rollback requests).
        
        Entity Types:
        - change_requests: Manage change requests
        - rollback_requests: Manage rollback requests
        
        Actions:
        - create: Create new change or rollback request
        - update: Update existing change or rollback request
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        def generate_number(entity_type: str, entity_id: int) -> str:
            """Generate entity number based on type"""
            if entity_type == "change_requests":
                return f"CHG{str(entity_id).zfill(7)}"
            elif entity_type == "rollback_requests":
                return f"RBK{str(entity_id).zfill(7)}"
        
        if entity_type not in ["change_requests", "rollback_requests"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'change_requests' or 'rollback_requests'"
            })
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": f"Invalid data format for {entity_type}"
            })
        
        # get existing data tables
        change_requests = data.get("change_requests", {})
        rollback_requests = data.get("rollback_requests", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_change_types = ["standard", "normal", "emergency"]
        valid_risk_levels = ["low", "medium", "high", "critical"]
        valid_change_statuses = ["requested", "approved", "denied", "scheduled", "implemented", "cancelled", "rolled_back"]
        valid_rollback_statuses = ["requested", "approved", "executed", "failed"]

        
        # Handle change_requests
        if entity_type == "change_requests":
            # for create action
            if action == "create":
                if not change_control_data:
                    return json.dumps({
                        "success": False,
                        "error": "change_control_data is required for create action"
                    })

                # Validate required fields for create
                required_fields = ["title", "description", "change_type", "risk_level", "requested_by"]
                
                missing_fields = [field for field in required_fields if field not in change_control_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                    })
                
                # Allowed fields
                allowed_fields = ["incident_id", "title", "description", "change_type", "risk_level", "requested_by", "approved_by", "status", "implementation_date"]

                change_fields = [field for field in change_control_data if field not in allowed_fields]
                if change_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Unrecognized fields in change_control_data: {', '.join(change_fields)}"
                    })
                
                # Validate title is not empty
                if not str(change_control_data["title"]).strip():
                    return json.dumps({
                        "success": False,
                        "error": "Halt: title cannot be empty"
                    })
                
                # Validate description is not empty
                if not str(change_control_data["description"]).strip():
                    return json.dumps({
                        "success": False,
                        "error": "Halt: description cannot be empty"
                    })
                
                # Validate change_type enum
                if change_control_data["change_type"] not in valid_change_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid change_type. Must be one of: {', '.join(valid_change_types)}"
                    })
                
                # Validate risk_level enum
                if change_control_data["risk_level"] not in valid_risk_levels:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid risk_level. Must be one of: {', '.join(valid_risk_levels)}"
                    })
                
                # Validate requested_by user exists
                if str(change_control_data["requested_by"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User requested_by not found"
                    })
                
                # Validate that requested_by user is active
                if users[str(change_control_data["requested_by"])]["status"] != "active": 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User requested_by must be active" 
                    })
                
                if "approved_by" in change_control_data:
                    # Validate approved_by user exists if provided
                    if str(change_control_data["approved_by"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User approved_by not found"
                        })
                    
                    # Validate that approved_by user is active
                    if users[str(change_control_data["approved_by"])]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User approved_by must be active"
                        })
                
                # Validate incident_id exists if provided
                if "incident_id" in change_control_data and change_control_data["incident_id"] not in incidents:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Incident not found"
                    })
                
                # Validate status enum
                status = change_control_data.get("status", "requested")
                if status not in valid_change_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid change status - must be one of: {', '.join(valid_change_statuses)}"
                    })
                
                # Generate new change ID
                new_change_id = generate_id(change_requests)
                change_number = generate_number("change_requests", new_change_id)
                
                # Create new change request record
                new_change = {
                    "change_id": str(new_change_id),
                    "change_number": str(change_number),
                    "incident_id": str(change_control_data["incident_id"]) if "incident_id" in change_control_data else None,
                    "title": change_control_data["title"],
                    "description": change_control_data["description"],
                    "change_type": change_control_data["change_type"],
                    "risk_level": change_control_data["risk_level"],
                    "requested_by": change_control_data["requested_by"],
                    "approved_by": change_control_data["approved_by"] if "approved_by" in change_control_data else None,
                    "status": status,
                    "implementation_date": change_control_data["implementation_date"] if "implementation_date" in change_control_data else None,
                    "created_at": "2025-10-07T00:00:00",
                    "updated_at": "2025-10-07T00:00:00"
                }
                
                change_requests[str(new_change_id)] = new_change
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "change_id": str(new_change_id),
                    "message": f"Change request {new_change_id} created successfully",
                    "change_data": new_change
                })
            

            # for update action
            elif action == "update":
                if not change_id:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: change_id is required for update action"
                    })
                
                if str(change_id) not in change_requests:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Change request not found"
                    })
                
                if not change_control_data:
                    return json.dumps({
                        "success": False,
                        "error": "change_control_data is required for create action"
                    })
                
                # Validate at least one optional field is provided
                update_fields = ["incident_id", "title", "description", "change_type", "risk_level", "requested_by", "approved_by", "status", "implementation_date"]

                provided_fields = [field for field in update_fields if field in change_control_data]
                if not provided_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                    })
                
                # Validate only allowed fields for updates
                invalid_fields = [field for field in change_control_data.keys() if field not in update_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields for change updating: {', '.join(invalid_fields)}"
                    })

                if "title" in change_control_data:
                    if not str(change_control_data["title"]).strip():
                        return json.dumps({
                            "success": False,
                            "error": "Halt: title cannot be empty"
                        })
                
                if "description" in change_control_data:
                    if not str(change_control_data["description"]).strip():
                        return json.dumps({
                            "success": False,
                            "error": "Halt: description cannot be empty"
                        })
                
                if "change_type" in change_control_data:
                    if change_control_data["change_type"] not in valid_change_types:
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: Invalid change_type. Must be one of: {', '.join(valid_change_types)}"
                        })
                
                if "risk_level" in change_control_data:
                    if change_control_data["risk_level"] not in valid_risk_levels:
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: Invalid risk_level. Must be one of: {', '.join(valid_risk_levels)}"
                        })
                
                if "approved_by" in change_control_data:
                    if str(change_control_data["approved_by"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User approved_by not found"
                        })
                    
                    if users[str(change_control_data["approved_by"])]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User approved_by must be active"
                        })
                    
                if "status" in change_control_data:
                    if change_control_data["status"] not in valid_change_statuses:
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_change_statuses)}"
                        })
                
                if "incident_id" in change_control_data:
                    if change_control_data["incident_id"] not in incidents:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Incident not found"
                        })
                
                # Get current change request record
                current_change = change_requests[str(change_id)]
                # Update change request record
                updated_change = current_change.copy()
                for key, value in change_control_data.items():
                    if key in ["incident_id", "approved_by", "implementation_date"]:
                        updated_change[key] = str(value) if value not in (None, "") else None
                    else:
                        updated_change[key] = value
                
                updated_change["updated_at"] = "2025-10-07T00:00:00"

                change_requests[change_id] = updated_change
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "change_id": str(change_id),
                    "message": f"Change request {change_id} updated successfully",
                    "change_data": updated_change
                })
        
        # Handle rollback_requests
        elif entity_type == "rollback_requests":
            # for create action
            if action == "create":
                if not change_control_data:
                    return json.dumps({
                        "success": False,
                        "error": "change_control_data is required for create action"
                    })
                
                # Validate required fields for create
                required_fields = ["change_id", "title", "rollback_reason", "requested_by"]
                
                missing_fields = [field for field in required_fields if field not in change_control_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                    })
                
                # Allowed fields
                allowed_fields = ["change_id", "incident_id", "title", "rollback_reason", "requested_by", "status", "executed_at"]

                rollback_fields = [field for field in change_control_data if field not in allowed_fields]
                if rollback_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Unrecognized fields in change_control_data: {', '.join(rollback_fields)}"
                    })

                # Validate change_id exists
                if str(change_control_data["change_id"]) not in change_requests:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Change request not found"
                    })
                
                # Validate that incident exists if provided
                if "incident_id" in change_control_data:
                    if str(change_control_data["incident_id"]) not in incidents:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Incident not found"
                        })
                
                # Validate title is not empty
                if not str(change_control_data["title"]).strip():
                    return json.dumps({
                        "success": False,
                        "error": "Halt: title cannot be empty"
                    })
                
                # Validate rollback_reason is not empty
                if not str(change_control_data["rollback_reason"]).strip():
                    return json.dumps({
                        "success": False,
                        "error": "Halt: rollback_reason cannot be empty"
                    })
                
                # Validate requested_by user exists
                if str(change_control_data["requested_by"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User requested_by not found"
                    })
                
                # Validate that requested_by user is active
                if users[str(change_control_data["requested_by"])]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User requested_by must be active"
                    })
                
                # Validate status enum
                status = change_control_data.get("status", "requested")
                if status not in valid_rollback_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: Invalid rollback status - must be one of: {', '.join(valid_rollback_statuses)}"
                    })
                
                # Generate new rollback ID
                new_rollback_id = generate_id(rollback_requests)
                rollback_number = generate_number("rollback_requests", new_rollback_id)
                
                # Create new rollback request record
                new_rollback = {
                    "rollback_id": str(new_rollback_id),
                    "rollback_number": str(rollback_number),
                    "change_id": str(change_control_data["change_id"]),
                    "incident_id": str(change_control_data["incident_id"]) if "incident_id" in change_control_data else None,
                    "title": change_control_data["title"],
                    "rollback_reason": change_control_data["rollback_reason"],
                    "requested_by": change_control_data["requested_by"],
                    "status": status,
                    "executed_at": change_control_data["executed_at"] if "executed_at" in change_control_data else None,
                    "created_at": "2025-10-07T00:00:00"
                }
                
                rollback_requests[str(new_rollback_id)] = new_rollback
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "rollback_id": str(new_rollback_id),
                    "message": f"Rollback request {new_rollback_id} created successfully",
                    "rollback_data": new_rollback
                })
            
            # for update action
            elif action == "update":
                if not rollback_id:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: rollback_id is required for update action"
                    })
                
                if rollback_id not in rollback_requests:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Rollback request not found"
                    })
                
                if not change_control_data:
                    return json.dumps({
                        "success": False,
                        "error": "change_control_data is required for update action"
                    })
                
                update_fields = ["change_id", "incident_id", "title", "rollback_reason", "requested_by", "status", "executed_at"]

                provided_fields = [field for field in update_fields if field in change_control_data]
                if not provided_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                    })
                
                # Validate only allowed fields for updates
                invalid_fields = [field for field in change_control_data.keys() if field not in update_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields for rollback updating: {', '.join(invalid_fields)}"
                    })

                # Validate change_id exists if provided
                if "change_id" in change_control_data:
                    if str(change_control_data["change_id"]) not in change_requests:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Change request not found"
                        })
                
                # Validate that incident exists if provided
                if "incident_id" in change_control_data:
                    if str(change_control_data["incident_id"]) not in incidents:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: Incident not found"
                        })
                
                # Validate title is not empty if provided
                if "title" in change_control_data:
                    if not str(change_control_data["title"]).strip():
                        return json.dumps({
                            "success": False,
                            "error": "Halt: title cannot be empty"
                        })
                
                # Validate rollback_reason is not empty if provided
                if "rollback_reason" in change_control_data:
                    if not str(change_control_data["rollback_reason"]).strip():
                        return json.dumps({
                            "success": False,
                            "error": "Halt: rollback_reason cannot be empty"
                        })
                
                # Validate requested_by user exists if provided
                if "requested_by" in change_control_data:
                    if str(change_control_data["requested_by"]) not in users:
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User requested_by not found"
                        })
                
                    # Validate that requested_by user is active
                    if users[str(change_control_data["requested_by"])]["status"] != "active":
                        return json.dumps({
                            "success": False,
                            "error": "Halt: User requested_by must be active"
                        })
                    
                if "status" in change_control_data:
                    if change_control_data["status"] not in valid_rollback_statuses:
                        return json.dumps({
                            "success": False,
                            "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_rollback_statuses)}"
                        })
                
                # Get current rollback request
                current_rollback = rollback_requests[str(rollback_id)]
                # Update rollback request record
                updated_rollback = current_rollback.copy()
                for key, value in change_control_data.items():
                    if key in ["incident_id", "executed_at"]:
                        updated_rollback[key] = str(value) if value not in (None, "") else None
                    else:
                        updated_rollback[key] = value
                
                rollback_requests[str(rollback_id)] = updated_rollback
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "rollback_id": str(rollback_id),
                    "message": f"Rollback request {rollback_id} updated successfully",
                    "rollback_data": updated_rollback
                })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_change_control",
                "description": "Create or update change control records (change requests or rollback requests) in the incident management system. This tool manages change control workflows with comprehensive validation of changes, rollbacks, risk levels, and approval processes. For change requests: creates and updates change records with proper validation of change types (standard, normal, emergency), risk levels (low, medium, high, critical), and status transitions. For rollback requests: manages rollback workflows linked to change requests and incidents. Validates user assignments, incident relationships, and maintains change audit trail. Essential for change management, rollback procedures, and maintaining proper change control processes.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "entity_type": {
                            "type": "string",
                            "description": "Entity type to manage: 'change_requests' for change requests, 'rollback_requests' for rollback requests",
                            "enum": ["change_requests", "rollback_requests"]
                        },
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to create new record, 'update' to modify existing record",
                            "enum": ["create", "update"]
                        },
                        "change_control_data": {
                            "type": "object",
                            "description": "Data for creating or updating change or rollback requests.",
                            "properties": {
                                "change_id": {
                                    "type": "string",
                                    "description": "Unique identifier of the change request (required for create of rollback_requests)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier (optional for create of rollback_requests or change_requests)"
                                },
                                "title": {
                                    "type": "string",
                                    "description": "Title of the change or rollback (required for create, cannot be empty)"
                                },
                                "change_type": {
                                    "type": "string",
                                    "description": "Type of change (required for create of change_requests). Must be one of: standard, normal, emergency",
                                    "enum": ["standard", "normal", "emergency"]
                                },
                                "risk_level": {
                                    "type": "string",
                                    "description": "Risk level of the change (required for create of change_requests). Must be one of: low, medium, high, critical",
                                    "enum": ["low", "medium", "high", "critical"]
                                },
                                "description": {
                                    "type": "string",
                                    "description": "Description of the change (required for create of change_requests, cannot be empty)"
                                },
                                "requested_by": {
                                    "type": "string",
                                    "description": "User identifier requesting the change or rollback (required for create, must exist in system)"
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User identifier approving the change (optional, must exist in system if provided)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Status of the change or rollback (required for create). For change_requests: requested, approved, denied, scheduled, implemented, cancelled, rolled_back. For rollback_requests: requested, approved, executed, failed"
                                },
                                "implementation_date": {
                                    "type": "string",
                                    "description": "Implementation timestamp in YYYY-MM-DDTHH:MM:SS format (for change_requests)"
                                },
                                "rollback_reason": {
                                    "type": "string",
                                    "description": "Reason for rollback (required for create of rollback_requests, cannot be empty)"
                                },
                                "executed_at": {
                                    "type": "string",
                                    "description": "Execution timestamp in YYYY-MM-DDTHH:MM:SS format (for rollback_requests)"
                                }
                            }
                        },
                        "change_id": {
                            "type": "string",
                            "description": "Unique identifier of the change request (required for update of change_requests)"
                        },
                        "rollback_id": {
                            "type": "string",
                            "description": "Unique identifier of the rollback request (required for update of rollback_requests)"
                        }
                    },
                    "required": ["entity_type", "action"]
                }
            }
        }
import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageClientVendors(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_type: str,
        entity_data: Optional[Dict[str, Any]] = None,
        entity_id: Optional[str] = None
    ) -> str:
        """
        Create or update client and vendor records.
        
        Actions:
        - create: Create new client or vendor record (requires entity_data)
        - update: Update existing client or vendor record (requires entity_id and entity_data)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if entity_type not in ["clients", "vendors"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'clients' or 'vendors'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        # ========== CLIENTS ==========
        if entity_type == "clients":
            clients = data.get("clients", {})
            
            if action == "create":
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for create action"
                    })
                
                # Validate required fields
                required_fields = ["client_name", "company_type", "contact_email", "support_coverage", "preferred_communication"]
                missing_fields = [field for field in required_fields if field not in entity_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Missing required fields: {', '.join(missing_fields)}"
                    })
                
                # Validate allowed fields
                allowed_fields = ["client_name", "registration_number", "company_type", "address", "contact_phone", "contact_email", "support_coverage", "preferred_communication", "status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate enums
                valid_company_types = ["enterprise", "mid_market", "smb", "startup"]
                if entity_data["company_type"] not in valid_company_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid company_type '{entity_data['company_type']}'. Must be one of: {', '.join(valid_company_types)}"
                    })
                
                valid_support_coverage = ["24x7", "business_hours", "on_call"]
                if entity_data["support_coverage"] not in valid_support_coverage:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid support_coverage '{entity_data['support_coverage']}'. Must be one of: {', '.join(valid_support_coverage)}"
                    })
                
                valid_preferred_communication = ["email", "portal", "phone", "slack"]
                if entity_data["preferred_communication"] not in valid_preferred_communication:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid preferred_communication '{entity_data['preferred_communication']}'. Must be one of: {', '.join(valid_preferred_communication)}"
                    })
                
                if "status" in entity_data:
                    valid_status = ["active", "inactive", "pending"]
                    if entity_data["status"] not in valid_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid status '{entity_data['status']}'. Must be one of: {', '.join(valid_status)}"
                        })
                
                # Check registration_number uniqueness
                if "registration_number" in entity_data and entity_data["registration_number"]:
                    for client in clients.values():
                        if client.get("registration_number") == entity_data["registration_number"]:
                            return json.dumps({
                                "success": False,
                                "error": "Registration number already exists"
                            })
                
                # Create new client
                new_id = str(generate_id(clients))
                new_client = {
                    "client_id": new_id,
                    "client_name": entity_data["client_name"],
                    "registration_number": entity_data.get("registration_number"),
                    "company_type": entity_data["company_type"],
                    "address": entity_data.get("address"),
                    "contact_phone": entity_data.get("contact_phone"),
                    "contact_email": entity_data["contact_email"],
                    "support_coverage": entity_data["support_coverage"],
                    "preferred_communication": entity_data["preferred_communication"],
                    "status": entity_data.get("status", "active"),
                    "created_at": timestamp,
                    "updated_at": timestamp
                }
                clients[new_id] = new_client
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": "clients",
                    "client_id": new_id,
                    "client_data": new_client
                })
            
            elif action == "update":
                if not entity_id:
                    return json.dumps({
                        "success": False,
                        "error": "entity_id is required for update action"
                    })
                
                if entity_id not in clients:
                    return json.dumps({
                        "success": False,
                        "error": f"Client {entity_id} not found"
                    })
                
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for update action"
                    })
                
                # Validate allowed fields
                allowed_fields = ["client_name", "registration_number", "company_type", "address", "contact_phone", "contact_email", "support_coverage", "preferred_communication", "status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate enums if provided
                if "company_type" in entity_data:
                    valid_company_types = ["enterprise", "mid_market", "smb", "startup"]
                    if entity_data["company_type"] not in valid_company_types:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid company_type. Must be one of: {', '.join(valid_company_types)}"
                        })
                
                if "support_coverage" in entity_data:
                    valid_support_coverage = ["24x7", "business_hours", "on_call"]
                    if entity_data["support_coverage"] not in valid_support_coverage:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid support_coverage. Must be one of: {', '.join(valid_support_coverage)}"
                        })
                
                if "preferred_communication" in entity_data:
                    valid_preferred_communication = ["email", "portal", "phone", "slack"]
                    if entity_data["preferred_communication"] not in valid_preferred_communication:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid preferred_communication. Must be one of: {', '.join(valid_preferred_communication)}"
                        })
                
                if "status" in entity_data:
                    valid_status = ["active", "inactive", "pending"]
                    if entity_data["status"] not in valid_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                        })
                
                # Check registration_number uniqueness if being updated
                if "registration_number" in entity_data and entity_data["registration_number"]:
                    for cid, client in clients.items():
                        if cid != entity_id and client.get("registration_number") == entity_data["registration_number"]:
                            return json.dumps({
                                "success": False,
                                "error": "New registration_number already exists"
                            })
                
                # Update client
                updated_client = clients[entity_id].copy()
                for key, value in entity_data.items():
                    updated_client[key] = value
                updated_client["updated_at"] = timestamp
                clients[entity_id] = updated_client
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "entity_type": "clients",
                    "client_id": entity_id,
                    "client_data": updated_client
                })
        
        # ========== VENDORS ==========
        elif entity_type == "vendors":
            vendors = data.get("vendors", {})
            
            if action == "create":
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for create action"
                    })
                
                # Validate required fields
                required_fields = ["vendor_name"]
                missing_fields = [field for field in required_fields if field not in entity_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Missing required fields: {', '.join(missing_fields)}"
                    })
                
                # Validate allowed fields
                allowed_fields = ["vendor_name", "contact_email", "contact_phone", "status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate status enum
                if "status" in entity_data:
                    valid_status = ["active", "inactive"]
                    if entity_data["status"] not in valid_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid status '{entity_data['status']}'. Must be one of: {', '.join(valid_status)}"
                        })
                
                # Create new vendor
                new_id = str(generate_id(vendors))
                new_vendor = {
                    "vendor_id": new_id,
                    "vendor_name": entity_data["vendor_name"],
                    "contact_email": entity_data.get("contact_email"),
                    "contact_phone": entity_data.get("contact_phone"),
                    "status": entity_data.get("status", "active"),
                    "created_at": timestamp
                }
                vendors[new_id] = new_vendor
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": "vendors",
                    "vendor_id": new_id,
                    "vendor_data": new_vendor
                })
            
            elif action == "update":
                if not entity_id:
                    return json.dumps({
                        "success": False,
                        "error": "entity_id is required for update action"
                    })
                
                if entity_id not in vendors:
                    return json.dumps({
                        "success": False,
                        "error": f"Vendor {entity_id} not found"
                    })
                
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for update action"
                    })
                
                # Validate allowed fields
                allowed_fields = ["vendor_name", "contact_email", "contact_phone", "status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate status enum if provided
                if "status" in entity_data:
                    valid_status = ["active", "inactive"]
                    if entity_data["status"] not in valid_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                        })
                
                # Update vendor
                updated_vendor = vendors[entity_id].copy()
                for key, value in entity_data.items():
                    updated_vendor[key] = value
                vendors[entity_id] = updated_vendor
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "entity_type": "vendors",
                    "vendor_id": entity_id,
                    "vendor_data": updated_vendor
                })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_client_vendors",
                "description": "Create or update client and vendor records in the incident management system. For creation, establishes new client or vendor records with comprehensive validation. For updates, modifies existing records while maintaining data integrity. Validates company types, support coverage, communication preferences, and status values according to system requirements.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new record, 'update' to modify existing record",
                            "enum": ["create", "update"]
                        },
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to manage: 'clients' or 'vendors'",
                            "enum": ["clients", "vendors"]
                        },
                        "entity_data": {
                            "type": "object",
                            "description": "Entity data object. For clients create: requires client_name, company_type ('enterprise', 'mid_market', 'smb', 'startup'), contact_email, support_coverage ('24x7', 'business_hours', 'on_call'), preferred_communication ('email', 'portal', 'phone', 'slack'), with optional registration_number, address, contact_phone, status ('active', 'inactive', 'pending'). For vendors create: requires vendor_name, with optional contact_email, contact_phone, status ('active', 'inactive'). For update: includes fields to change. SYNTAX: {\"key\": \"value\"}"
                        },
                        "entity_id": {
                            "type": "string",
                            "description": "Unique identifier of the entity record (client_id for clients, vendor_id for vendors). Required for update action only."
                        }
                    },
                    "required": ["action", "entity_type"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageCommunications(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, communication_data: Dict[str, Any] = None, communication_id: str = None) -> str:
        """
        Create or update communication records for incident notifications.

        Actions:
        - create: Create new communication (requires incident_id, communication_type, recipient_type, sender, delivery_method, message_content)
        - update: Update existing communication (requires communication_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for communications"
            })
        
        # get existing data tables
        communications = data.get("communications", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_types = ["status_update", "resolution_notice", "escalation_notice", "bridge_invitation"]
        valid_recipient_types = ["client", "internal", "vendor", "executive"]
        valid_methods = ["email", "portal", "sms", "phone"]
        valid_statuses = ["pending", "sent", "delivered", "failed"]


        # for create action
        if action == "create":
            if not communication_data:
                return json.dumps({
                    "success": False,
                    "error": "communication_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["incident_id", "communication_type", "recipient_type", "sender", "delivery_method", "message_content"]
            
            missing_fields = [field for field in required_fields if field not in communication_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication details - missing fields: {', '.join(missing_fields)}"
                })
            
            # Validate incident exists
            if str(communication_data["incident_id"]) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Incident not found"
                })
            
            # Validate sender exists
            if str(communication_data["sender"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Sender user not found"
                })
            
            # Validate recipient if provided
            if communication_data.get("recipient"):
                if str(communication_data["recipient"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: Recipient user not found"
                    })
            
            # Validate communication_type
            if communication_data["communication_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication type - must be one of: {', '.join(valid_types)}"
                })
            
            # Validate recipient_type
            if communication_data["recipient_type"] not in valid_recipient_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid recipient type - must be one of: {', '.join(valid_recipient_types)}"
                })
            
            # Validate delivery_method
            if communication_data["delivery_method"] not in valid_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery method - must be one of: {', '.join(valid_methods)}"
                })
            
            # Validate delivery_status
            delivery_status = communication_data.get("delivery_status", "pending")
            if delivery_status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Generate new communication ID
            new_comm_id = generate_id(communications)
            
            # Create new communication record
            new_comm = {
                "communication_id": str(new_comm_id),
                "incident_id": str(communication_data["incident_id"]),
                "communication_type": communication_data["communication_type"],
                "recipient_type": communication_data["recipient_type"],
                "sender": str(communication_data["sender"]),
                "recipient": str(communication_data["recipient"]) if communication_data.get("recipient") not in (None, "") else None,
                "delivery_method": communication_data["delivery_method"],
                "message_content": communication_data["message_content"],
                "delivery_status": delivery_status,
                "sent_at": communication_data.get("sent_at") or None,
                "created_at": "2025-10-07T00:00:00"
            }
            
            communications[str(new_comm_id)] = new_comm
            
            return json.dumps({
                "success": True,
                "action": "create",
                "communication_id": str(new_comm_id),
                "message": f"Communication {new_comm_id} created successfully",
                "communication_data": new_comm
            })
        
        
        # for update action
        elif action == "update":
            if not communication_id:
                return json.dumps({
                    "success": False,
                    "error": "communication_id is required for update action"
                })

            if str(communication_id) not in communications:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Communication not found"
                })
            
            if not communication_data:
                return json.dumps({
                    "success": False,
                    "error": "communication_data is required for update action"
                })
            
            # Validate at least one optional field is provided
            update_fields = ["communication_type", "recipient_type", "recipient", "delivery_method", "message_content", "delivery_status"]
            provided_fields = [field for field in update_fields if field in communication_data]
            if not provided_fields:
                return json.dumps({
                    "success": False,
                    "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                })
            
            # Validate only allowed fields for updates
            invalid_fields = [field for field in communication_data.keys() if field not in update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for communication updating: {', '.join(invalid_fields)}"
                })

            # Validate communication type if provided
            if "communication_type" in communication_data and communication_data["communication_type"] not in valid_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid communication type - must be one of: {', '.join(valid_types)}"
                })
            
            # Validate recipient type if provided
            if "recipient_type" in communication_data and communication_data["recipient_type"] not in valid_recipient_types:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid recipient type - must be one of: {', '.join(valid_recipient_types)}"
                })
            
            # Validate delivery method if provided
            if "delivery_method" in communication_data and communication_data["delivery_method"] not in valid_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery method - must be one of: {', '.join(valid_methods)}"
                })
            
            # Validate delivery_status if provided
            if "delivery_status" in communication_data and communication_data["delivery_status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid delivery status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Validate recipient if provided
            if "recipient" in communication_data and str(communication_data["recipient"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Recipient user not found"
                })
            
            # Get current communication record
            current_comm = communications[str(communication_id)]
            # Update communication record with modified information
            updated_comm = current_comm.copy()
            for key, value in communication_data.items():
                if key == "recipient":
                    updated_comm[key] = str(value) if value not in (None, "") else None
                else:
                    updated_comm[key] = value

            communications[str(communication_id)] = updated_comm
            
            return json.dumps({
                "success": True,
                "action": "update",
                "communication_id": str(communication_id),
                "message": f"Communication {communication_id} updated successfully",
                "communication_data": updated_comm
            })
        
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_communications",
                "description": "Create or update communication records for incident notifications in the incident management system. This tool manages all incident-related communications including status updates, resolution notices, escalation notifications, and bridge invitations. Handles multi-channel delivery (email, portal, SMS, phone) to various recipient types (client, internal, vendor, executive). Validates sender/recipient user existence, ensures proper communication types, tracks delivery status, and maintains communication audit trail. Essential for stakeholder management, SLA compliance, and maintaining transparency throughout incident lifecycle.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to record new communication or 'update' to modify existing communication",
                            "enum": ["create", "update"]
                        },
                        "communication_data": {
                            "type": "object",
                            "description": "Details of the communication to create or update",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier (required for create)"
                                },
                                "communication_type": {
                                    "type": "string",
                                    "description": "Type of communication (required for create): status_update, resolution_notice, escalation_notice, bridge_invitation",
                                    "enum": ["status_update", "resolution_notice", "escalation_notice", "bridge_invitation"]
                                },
                                "recipient_type": {
                                    "type": "string",
                                    "description": "Type of recipient (required for create): client, internal, vendor, executive",
                                    "enum": ["client", "internal", "vendor", "executive"]
                                },
                                "sender": {
                                    "type": "string",
                                    "description": "User identifier sending the communication (required for create, must exist in system)"
                                },
                                "recipient": {
                                    "type": "string",
                                    "description": "Specific user identifier receiving the communication (optional, must exist if provided)"
                                },
                                "delivery_method": {
                                    "type": "string",
                                    "description": "Method of delivery (required for create): email, portal, sms, phone",
                                    "enum": ["email", "portal", "sms", "phone"]
                                },
                                "message_content": {
                                    "type": "string",
                                    "description": "Content of the communication message (required for create)"
                                },
                                "sent_at": {
                                    "type": "string",
                                    "description": "Timestamp when communication was sent in YYYY-MM-DDTHH:MM:SS format"
                                },
                                "delivery_status": {
                                    "type": "string",
                                    "description": "Delivery status (required for create): pending, sent, delivered, failed",
                                    "enum": ["pending", "sent", "delivered", "failed"]
                                }
                            }
                        },
                        "communication_id": {
                            "type": "string",
                            "description": "Unique identifier of the communication (provide this to update existing communication)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }
import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageContracts(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        entity_type: str,
        entity_data: Optional[Dict[str, Any]] = None,
        entity_id: Optional[str] = None
    ) -> str:
        """
        Create or update subscription and SLA agreement records.
        
        Actions:
        - create: Create new subscription or SLA agreement record (requires entity_data)
        - update: Update existing subscription or SLA agreement record (requires entity_id and entity_data)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if entity_type not in ["subscriptions", "sla_agreements"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid entity_type '{entity_type}'. Must be 'subscriptions' or 'sla_agreements'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        # ========== SUBSCRIPTIONS ==========
        if entity_type == "subscriptions":
            subscriptions = data.get("subscriptions", {})
            clients = data.get("clients", {})
            
            if action == "create":
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for create action"
                    })
                
                # Validate required fields
                required_fields = ["client_id", "tier", "start_date"]
                missing_fields = [field for field in required_fields if field not in entity_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Missing required fields: {', '.join(missing_fields)}"
                    })
                
                # Validate allowed fields
                allowed_fields = ["client_id", "tier", "start_date", "end_date", "status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate tier enum
                valid_tiers = ["premium", "standard", "basic"]
                if entity_data["tier"] not in valid_tiers:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid tier '{entity_data['tier']}'. Must be one of: {', '.join(valid_tiers)}"
                    })
                
                # Validate status enum if provided
                if "status" in entity_data:
                    valid_status = ["active", "expired", "cancelled"]
                    if entity_data["status"] not in valid_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid status '{entity_data['status']}'. Must be one of: {', '.join(valid_status)}"
                        })
                
                # Validate client_id exists
                if entity_data["client_id"] not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
                
                # Create new subscription
                new_id = str(generate_id(subscriptions))
                new_subscription = {
                    "subscription_id": new_id,
                    "client_id": entity_data["client_id"],
                    "tier": entity_data["tier"],
                    "start_date": entity_data["start_date"],
                    "end_date": entity_data.get("end_date"),
                    "status": entity_data.get("status", "active"),
                    "created_at": timestamp,
                    "updated_at": timestamp
                }
                subscriptions[new_id] = new_subscription
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": "subscriptions",
                    "subscription_id": new_id,
                    "subscription_data": new_subscription
                })
            
            elif action == "update":
                if not entity_id:
                    return json.dumps({
                        "success": False,
                        "error": "entity_id is required for update action"
                    })
                
                if entity_id not in subscriptions:
                    return json.dumps({
                        "success": False,
                        "error": f"Subscription {entity_id} not found"
                    })
                
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for update action"
                    })
                
                # Validate allowed fields
                allowed_fields = ["client_id", "tier", "start_date", "end_date", "status"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate tier enum if provided
                if "tier" in entity_data:
                    valid_tiers = ["premium", "standard", "basic"]
                    if entity_data["tier"] not in valid_tiers:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid tier. Must be one of: {', '.join(valid_tiers)}"
                        })
                
                # Validate status enum if provided
                if "status" in entity_data:
                    valid_status = ["active", "expired", "cancelled"]
                    if entity_data["status"] not in valid_status:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                        })
                
                # Validate client_id if being updated
                if "client_id" in entity_data:
                    if entity_data["client_id"] not in clients:
                        return json.dumps({
                            "success": False,
                            "error": "Client not found"
                        })
                
                # Update subscription
                updated_subscription = subscriptions[entity_id].copy()
                for key, value in entity_data.items():
                    updated_subscription[key] = value
                updated_subscription["updated_at"] = timestamp
                subscriptions[entity_id] = updated_subscription
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "entity_type": "subscriptions",
                    "subscription_id": entity_id,
                    "subscription_data": updated_subscription
                })
        
        # ========== SLA AGREEMENTS ==========
        elif entity_type == "sla_agreements":
            sla_agreements = data.get("sla_agreements", {})
            subscriptions = data.get("subscriptions", {})
            users = data.get("users", {})
            
            if action == "create":
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for create action"
                    })
                
                # Validate required fields
                required_fields = ["subscription_id", "severity_level", "response_time_minutes", "resolution_time_minutes", "created_by"]
                missing_fields = [field for field in required_fields if field not in entity_data]
                if missing_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Missing required fields: {', '.join(missing_fields)}"
                    })
                
                # Validate allowed fields
                allowed_fields = ["subscription_id", "severity_level", "response_time_minutes", "resolution_time_minutes", "availability_guarantee", "created_by"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate severity_level enum
                valid_severity_levels = ["P1", "P2", "P3", "P4"]
                if entity_data["severity_level"] not in valid_severity_levels:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid severity_level '{entity_data['severity_level']}'. Must be one of: {', '.join(valid_severity_levels)}"
                    })
                
                # Validate subscription_id exists
                if entity_data["subscription_id"] not in subscriptions:
                    return json.dumps({
                        "success": False,
                        "error": "Subscription not found"
                    })
                
                # Validate created_by exists
                if entity_data["created_by"] not in users:
                    return json.dumps({
                        "success": False,
                        "error": "User not found"
                    })
                
                # Check uniqueness: one SLA per subscription per severity level
                for sla in sla_agreements.values():
                    if sla.get("subscription_id") == entity_data["subscription_id"] and sla.get("severity_level") == entity_data["severity_level"]:
                        return json.dumps({
                            "success": False,
                            "error": "SLA agreement already exists for this subscription and severity level"
                        })
                
                # Create new SLA agreement
                new_id = str(generate_id(sla_agreements))
                new_sla = {
                    "sla_id": new_id,
                    "subscription_id": entity_data["subscription_id"],
                    "severity_level": entity_data["severity_level"],
                    "response_time_minutes": entity_data["response_time_minutes"],
                    "resolution_time_minutes": entity_data["resolution_time_minutes"],
                    "availability_guarantee": entity_data.get("availability_guarantee"),
                    "created_by": entity_data["created_by"],
                    "created_at": timestamp
                }
                sla_agreements[new_id] = new_sla
                
                return json.dumps({
                    "success": True,
                    "action": "create",
                    "entity_type": "sla_agreements",
                    "sla_id": new_id,
                    "sla_data": new_sla
                })
            
            elif action == "update":
                if not entity_id:
                    return json.dumps({
                        "success": False,
                        "error": "entity_id is required for update action"
                    })
                
                if entity_id not in sla_agreements:
                    return json.dumps({
                        "success": False,
                        "error": f"SLA agreement {entity_id} not found"
                    })
                
                if not entity_data:
                    return json.dumps({
                        "success": False,
                        "error": "entity_data is required for update action"
                    })
                
                # Validate allowed fields
                allowed_fields = ["subscription_id", "severity_level", "response_time_minutes", "resolution_time_minutes", "availability_guarantee", "created_by"]
                invalid_fields = [field for field in entity_data.keys() if field not in allowed_fields]
                if invalid_fields:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid fields: {', '.join(invalid_fields)}"
                    })
                
                # Validate severity_level enum if provided
                if "severity_level" in entity_data:
                    valid_severity_levels = ["P1", "P2", "P3", "P4"]
                    if entity_data["severity_level"] not in valid_severity_levels:
                        return json.dumps({
                            "success": False,
                            "error": f"Invalid severity_level. Must be one of: {', '.join(valid_severity_levels)}"
                        })
                
                # Validate subscription_id if being updated
                if "subscription_id" in entity_data:
                    if entity_data["subscription_id"] not in subscriptions:
                        return json.dumps({
                            "success": False,
                            "error": "Subscription not found"
                        })
                
                # Validate created_by if being updated
                if "created_by" in entity_data:
                    if entity_data["created_by"] not in users:
                        return json.dumps({
                            "success": False,
                            "error": "User not found"
                        })
                
                # Check uniqueness if subscription_id or severity_level is being updated
                current_sla = sla_agreements[entity_id]
                new_subscription_id = entity_data.get("subscription_id", current_sla.get("subscription_id"))
                new_severity_level = entity_data.get("severity_level", current_sla.get("severity_level"))
                
                if "subscription_id" in entity_data or "severity_level" in entity_data:
                    for sla_id, sla in sla_agreements.items():
                        if sla_id != entity_id and sla.get("subscription_id") == new_subscription_id and sla.get("severity_level") == new_severity_level:
                            return json.dumps({
                                "success": False,
                                "error": "New SLA agreement combination already exists for this subscription and severity level"
                            })
                
                # Update SLA agreement
                updated_sla = sla_agreements[entity_id].copy()
                for key, value in entity_data.items():
                    updated_sla[key] = value
                sla_agreements[entity_id] = updated_sla
                
                return json.dumps({
                    "success": True,
                    "action": "update",
                    "entity_type": "sla_agreements",
                    "sla_id": entity_id,
                    "sla_data": updated_sla
                })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_contracts",
                "description": "Create or update subscription and SLA agreement records in the incident management system. For creation, establishes new subscription or SLA agreement records with comprehensive validation. For updates, modifies existing records while maintaining data integrity. Validates subscription tiers, SLA severity levels, and ensures unique SLA agreements per subscription and severity level combination.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new record, 'update' to modify existing record",
                            "enum": ["create", "update"]
                        },
                        "entity_type": {
                            "type": "string",
                            "description": "Type of entity to manage: 'subscriptions' or 'sla_agreements'",
                            "enum": ["subscriptions", "sla_agreements"]
                        },
                        "entity_data": {
                            "type": "object",
                            "description": "Entity data object. For subscriptions create: requires client_id, tier ('premium', 'standard', 'basic'), start_date (YYYY-MM-DD), with optional end_date (YYYY-MM-DD), status ('active', 'expired', 'cancelled'). For sla_agreements create: requires subscription_id, severity_level ('P1', 'P2', 'P3', 'P4'), response_time_minutes, resolution_time_minutes, created_by, with optional availability_guarantee. For update: includes fields to change. SYNTAX: {\"key\": \"value\"}"
                        },
                        "entity_id": {
                            "type": "string",
                            "description": "Unique identifier of the entity record (subscription_id for subscriptions, sla_id for sla_agreements). Required for update action only."
                        }
                    },
                    "required": ["action", "entity_type"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageEscalations(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, escalation_data: Dict[str, Any] = None, escalation_id: str = None) -> str:
        """
        Create or update escalation records.
        
        Actions:
        - create: Create new escalation (requires incident_id, escalated_from, escalated_to, escalation_level, escalation_reason)
        - update: Update existing escalation (requires escalation_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format for escalations"
            })
        
        # get existing data tables
        escalations = data.get("escalations", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_levels = ["L1_to_L2", "L2_to_L3", "L3_to_management", "management_to_executive"]
        valid_statuses = ["pending", "approved", "denied", "cancelled"]

        # allowed values
        required_incident_statuses = ["open", "in_progress"]
        required_user_status = ["active"]


        # for create action
        if action == "create":
            if not escalation_data:
                return json.dumps({
                    "success": False,
                    "error": "escalation_data is required for create action"
                })

            # Validate required fields for create
            required_fields = ["incident_id", "escalated_from", "escalated_to", "escalation_level", "escalation_reason"]
            
            missing_fields = [field for field in required_fields if field not in escalation_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Missing required fields for create action: {', '.join(missing_fields)}"
                })
            
            # Validate that incident exists
            if str(escalation_data["incident_id"]) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Incident not found"
                })
            
            # Validate that incident is open or in_progress
            incident_status = incidents[str(escalation_data["incident_id"])]["status"]
            if incident_status not in required_incident_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Incident status must be one of: {', '.join(required_incident_statuses)}"
                })
            
            # Validate that escalated_from user exists
            if str(escalation_data["escalated_from"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: User escalated_from not found"
                })
            
            # Validate that escalated_to user exists
            if str(escalation_data["escalated_to"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: User escalated_to not found"
                })
            
            # Validate that both escalated_to and escalated_from users are active
            for key in ["escalated_to", "escalated_from"]:
                user_id = str(escalation_data[key])
                if users[user_id]["status"] not in required_user_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Halt: User {key} must be active"
                    })
            
            # Validate escalation_level enum
            if escalation_data["escalation_level"] not in valid_levels:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid escalation_level. Must be one of: {', '.join(valid_levels)}"
                })
            
            # Validate escalation_reason is not empty
            if not escalation_data.get("escalation_reason") or not escalation_data.get("escalation_reason", "").strip():
                return json.dumps({
                    "success": False,
                    "error": "Halt: escalation_reason cannot be empty"
                })
            
            # Validate status
            status = escalation_data.get("delivery_status", "pending")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Generate new escalation ID
            new_escalation_id = generate_id(escalations)
            
            # Create new escalation record
            new_escalation = {
                "escalation_id": str(new_escalation_id),
                "incident_id": str(escalation_data["incident_id"]),
                "escalated_from": str(escalation_data["escalated_from"]),
                "escalated_to": str(escalation_data["escalated_to"]),
                "escalation_level": escalation_data["escalation_level"],
                "escalation_reason": escalation_data["escalation_reason"],
                "status": status,
                "requested_at": "2025-10-07T00:00:00",
                "responded_at": escalation_data["responded_at"] if "responded_at" in escalation_data else None
            }
            
            escalations[str(new_escalation_id)] = new_escalation
            
            return json.dumps({
                "success": True,
                "action": "create",
                "escalation_id": str(new_escalation_id),
                "message": f"Escalation {new_escalation_id} created successfully",
                "escalation_data": new_escalation
            })
        

        # for update action
        elif action == "update":
            if not escalation_id:
                return json.dumps({
                    "success": False,
                    "error": "Halt: escalation_id is required for update action"
                })
            
            if str(escalation_id) not in escalations:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Escalation not found"
                })
            
            if not escalation_data:
                return json.dumps({
                    "success": False,
                    "error": "escalation_data is required for update action"
                })
            
            # Validate at least one optional field is provided
            update_fields = ["status", "escalated_to", "responded_at"]
            provided_fields = [field for field in update_fields if field in escalation_data]
            if not provided_fields:
                return json.dumps({
                    "success": False,
                    "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                })

            # Validate user to reassign the escalation to exists if provided
            if "escalated_to" in escalation_data and str(escalation_data["escalated_to"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: User escalated_to not found"
                })
            
            # Validate that reassign escalated_to user is active
            if users[str(escalation_data["escalated_to"])]["status"] not in required_user_status: 
                return json.dumps({ 
                    "success": False, 
                    "error": "Halt: User escalated_to must be active" 
                })
            
            # Validate status if provided
            if "status" in escalation_data and escalation_data["status"] not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid status. Must be one of: {', '.join(valid_statuses)}"
                })
            

            # Get current escalation record
            current_escalation = escalations[str(escalation_id)]
            # Update escalation record with modified information
            updated_escalation = current_escalation.copy()
            for key, value in escalation_data.items():
                if key == "responded_at":
                    updated_escalation[key] = str(value) if value not in (None, "") else None
                else:
                    updated_escalation[key] = value
            
            escalations[str(escalation_id)] = updated_escalation
            
            return json.dumps({
                "success": True,
                "action": "update",
                "escalation_id": str(escalation_id),
                "message": f"Escalation {escalation_id} updated successfully",
                "escalation_data": updated_escalation
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_escalations",
                "description": "Create or update escalation records in the incident management system. This tool manages escalation workflows with comprehensive validation of users, incidents, escalation levels, and status transitions. For creation, establishes new escalations with proper validation of incident existence, user roles, and escalation paths. For updates, modifies existing escalation records including status changes and response timestamps. Validates escalation levels (L1_to_L2, L2_to_L3, L3_to_management, management_to_executive), ensures proper user assignments, and maintains escalation audit trail. Essential for incident escalation management, workflow tracking, and maintaining proper escalation procedures.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to create new escalation, 'update' to modify existing escalation",
                            "enum": ["create", "update"]
                        },
                        "escalation_data": {
                            "type": "object",
                            "description": "Details for creating or updating an escalation record",
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier (required for create, must exist in system)"
                                },
                                "escalated_from": {
                                    "type": "string",
                                    "description": "User identifier who requested the escalation (required for create, must exist in system)"
                                },
                                "escalated_to": {
                                    "type": "string",
                                    "description": "User identifier receiving the escalation (required for create, must exist in system)"
                                },
                                "escalation_level": {
                                    "type": "string",
                                    "description": "Escalation level (required for create). Must be one of: L1_to_L2, L2_to_L3, L3_to_management, management_to_executive",
                                    "enum": ["L1_to_L2", "L2_to_L3", "L3_to_management", "management_to_executive"]
                                },
                                "escalation_reason": {
                                    "type": "string",
                                    "description": "Reason for escalation (required for create, cannot be empty)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "Escalation status (required for create). Must be one of: pending, approved, denied, cancelled",
                                    "enum": ["pending", "approved", "denied", "cancelled"]
                                },
                                "responded_at": {
                                    "type": "string",
                                    "description": "Response timestamp in YYYY-MM-DDTHH:MM:SS format"
                                }
                            }
                        },
                        "escalation_id": {
                            "type": "string",
                            "description": "Unique identifier of the escalation (required for update action only)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }
import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageIncidentReports(Tool):
    """
    Create and update incident reports for tracking and documenting incidents.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        report_id: Optional[str] = None,
        incident_id: Optional[str] = None,
        report_title: Optional[str] = None,
        report_type: Optional[str] = None,
        report_content: Optional[str] = None,
        generated_by: Optional[str] = None
    ) -> str:
        """
        Create or update incident report records.

        Actions:
        - create: Create new incident report (requires incident_id, report_title, report_type, report_content, generated_by)
        - update: Update existing incident report (requires report_id and at least one field to update)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        def generate_report_number(report_id: str) -> str:
            """Generate a formatted report number."""
            return f"IR{report_id.zfill(8)}"

        timestamp = "2025-10-01T12:00:00"
        reports = data.get("incident_reports", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        valid_report_types = ["post_incident_review", "client_impact", "compliance"]
        valid_statuses = ["Draft", "In_Review", "Approved", "Published"]
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "update" and not report_id:
            return json.dumps({
                "success": False,
                "error": "report_id is required for update action"
            })

        if action == "create":
            if not all([incident_id, report_title, report_type, report_content, generated_by]):
                return json.dumps({
                    "success": False,
                    "error": "incident_id, report_title, report_type, report_content, and generated_by are required for create action"
                })

            # Validate incident exists
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident with ID {incident_id} not found"
                })

            # Validate user exists and is active
            if generated_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {generated_by} not found"
                })
            if users[generated_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {generated_by} is not active"
                })

            if report_type not in valid_report_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid report_type. Must be one of: {', '.join(valid_report_types)}"
                })

            if not report_title.strip():
                return json.dumps({
                    "success": False,
                    "error": "report_title cannot be empty"
                })

            if not report_content.strip():
                return json.dumps({
                    "success": False,
                    "error": "report_content cannot be empty"
                })

            new_id = generate_id(reports)
            report_number = generate_report_number(new_id)
            new_report = {
                "report_id": new_id,
                "report_number": report_number,
                "incident_id": incident_id,
                "report_title": report_title,
                "report_type": report_type,
                "report_content": report_content,
                "generated_by": generated_by,
                "generation_date": timestamp,
                "report_status": "Draft",
                "created_at": timestamp,
                "updated_at": timestamp,
                "last_modified_by": generated_by,
                "version": 1
            }
            reports[new_id] = new_report

            return json.dumps({
                "success": True,
                "action": "create",
                "report_id": new_id,
                "report_number": report_number,
                "report_data": new_report
            })

        if action == "update":
            if report_id not in reports:
                return json.dumps({
                    "success": False,
                    "error": f"Report with ID {report_id} not found"
                })

            # Validate at least one field is being updated
            if all(v is None for v in [report_title, report_type, report_content, generated_by]):
                return json.dumps({
                    "success": False,
                    "error": "At least one field must be provided for update"
                })

            existing_report = reports[report_id]

            if generated_by is not None:
                if generated_by not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {generated_by} not found"
                    })
                if users[generated_by]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {generated_by} is not active"
                    })

            if report_type is not None:
                if report_type not in valid_report_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid report_type. Must be one of: {', '.join(valid_report_types)}"
                    })
                existing_report["report_type"] = report_type

            if report_title is not None:
                if not report_title.strip():
                    return json.dumps({
                        "success": False,
                        "error": "report_title cannot be empty"
                    })
                existing_report["report_title"] = report_title

            if report_content is not None:
                if not report_content.strip():
                    return json.dumps({
                        "success": False,
                        "error": "report_content cannot be empty"
                    })
                existing_report["report_content"] = report_content
                existing_report["version"] += 1

            if generated_by is not None:
                existing_report["last_modified_by"] = generated_by

            existing_report["updated_at"] = timestamp

            return json.dumps({
                "success": True,
                "action": "update",
                "report_id": report_id,
                "report_number": existing_report["report_number"],
                "report_data": existing_report
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns comprehensive information about the tool's capabilities, parameters, and data schema.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_incident_reports",
                "description": "Create/update incident reports for formal documentation. Report types: post_incident_review, client_impact, compliance. Actions: 'create' (requires incident_id, report_title, report_type, report_content, generated_by), 'update' (requires report_id; optional: report_title, report_type, report_content, generated_by).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "report_id": {
                            "type": "string",
                            "description": "Required for update. ID of the report to update"
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "Required for create. ID of the incident this report belongs to"
                        },
                        "report_title": {
                            "type": "string",
                            "description": "Title/summary of the report (must not be empty)"
                        },
                        "report_type": {
                            "type": "string",
                            "description": "Type of incident report: post_incident_review (review after incident resolution), client_impact (client impact assessment), compliance (compliance documentation)",
                            "enum": ["post_incident_review", "client_impact", "compliance"]
                        },
                        "report_content": {
                            "type": "string",
                            "description": "Detailed content of the report (must not be empty)"
                        },
                        "generated_by": {
                            "type": "string",
                            "description": "ID of the active user creating/updating the report"
                        }
                    },
                    "required": ["action"]
                }
            }
        }import json
import os
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageIncidents(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        incident_id: Optional[str] = None,
        incident_data: Optional[Dict[str, Any]] = None,
    ) -> str:
        # Always resolve the correct "data" directory inside this environment
        TOOL_DIR = os.path.dirname(os.path.abspath(__file__))
        ENV_DIR = os.path.dirname(TOOL_DIR)
        DATA_DIR = os.path.join(ENV_DIR, "data")
        INCIDENTS_FP = os.path.join(DATA_DIR, "incidents.json")

        def ensure_dirs() -> None:
            os.makedirs(DATA_DIR, exist_ok=True)

        def load_incidents() -> Dict[str, Any]:
            """Read incidents from the correct JSON file."""
            if os.path.exists(INCIDENTS_FP):
                try:
                    with open(INCIDENTS_FP, "r") as f:
                        return json.load(f)
                except Exception:
                    return {}
            return {}

        def save_incidents(incidents_dict: Dict[str, Any]) -> None:
            """Write incidents back to the same JSON file."""
            ensure_dirs()
            with open(INCIDENTS_FP, "w") as f:
                json.dump(incidents_dict, f, indent=2)

        def generate_id(table: Dict[str, Any]) -> str:
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        def generate_incident_number(incidents_dict: Dict[str, Any]) -> str:
            if not incidents_dict:
                return "INC0000001"
            max_num = 0
            for inc in incidents_dict.values():
                inc_num = inc.get("incident_number", "INC0000000")
                try:
                    num = int(inc_num.replace("INC", ""))
                except Exception:
                    num = 0
                if num > max_num:
                    max_num = num
            return f"INC{str(max_num + 1).zfill(7)}"

        timestamp = "2025-10-01T00:00:00"

        incidents = data.setdefault("incidents", {})
        clients = data.setdefault("clients", {})
        configuration_items = data.setdefault("configuration_items", {})
        users = data.setdefault("users", {})
        problem_tickets = data.setdefault("problem_tickets", {})

        # Load existing file contents into memory
        if not incidents:
            loaded = load_incidents()
            if loaded:
                incidents.update(loaded)

        # Validate action
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        # ---------------- CREATE ----------------
        if action == "create":
            if not incident_data:
                return json.dumps({
                    "success": False,
                    "error": "incident_data is required for create action"
                })

            required_fields = [
                "title", "description", "client_id", "affected_ci_id",
                "severity", "impact", "urgency", "reported_by", "detection_time"
            ]
            missing = [f for f in required_fields if f not in incident_data]
            if missing:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing)}"
                })

            # Referential checks
            client_id = str(incident_data["client_id"])
            if client_id not in clients:
                return json.dumps({"success": False, "error": f"Client with ID '{client_id}' not found"})

            ci_id = str(incident_data["affected_ci_id"])
            if ci_id not in configuration_items:
                return json.dumps({"success": False, "error": f"Configuration item with ID '{ci_id}' not found"})

            reported_by = str(incident_data["reported_by"])
            if reported_by not in users:
                return json.dumps({"success": False, "error": f"User with ID '{reported_by}' not found"})

            if "assigned_to" in incident_data and incident_data["assigned_to"]:
                assigned_to = str(incident_data["assigned_to"])
                if assigned_to not in users:
                    return json.dumps({"success": False, "error": f"User with ID '{assigned_to}' not found"})

            if "problem_id" in incident_data and incident_data["problem_id"]:
                pid = str(incident_data["problem_id"])
                if pid not in problem_tickets:
                    return json.dumps({"success": False, "error": f"Problem ticket with ID '{pid}' not found"})

            # Enum validations
            valid_severities = ["P1", "P2", "P3", "P4"]
            valid_impacts = ["critical", "high", "medium", "low"]
            valid_urgencies = ["critical", "high", "medium", "low"]
            valid_categories = ["inquiry/help", "software", "hardware", "Network", "Database"]
            valid_statuses = ["open", "in_progress", "monitoring", "resolved", "closed"]

            if incident_data["severity"] not in valid_severities:
                return json.dumps({"success": False, "error": f"Invalid severity. Must be one of: {', '.join(valid_severities)}"})
            if incident_data["impact"] not in valid_impacts:
                return json.dumps({"success": False, "error": f"Invalid impact. Must be one of: {', '.join(valid_impacts)}"})
            if incident_data["urgency"] not in valid_urgencies:
                return json.dumps({"success": False, "error": f"Invalid urgency. Must be one of: {', '.join(valid_urgencies)}"})
            if "category" in incident_data and incident_data["category"]:
                if incident_data["category"] not in valid_categories:
                    return json.dumps({"success": False, "error": f"Invalid category. Must be one of: {', '.join(valid_categories)}"})
            if "status" in incident_data:
                if incident_data["status"] not in valid_statuses:
                    return json.dumps({"success": False, "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"})

            # Create new record
            new_id = generate_id(incidents)
            new_number = generate_incident_number(incidents)

            new_incident = {
                "incident_id": new_id,
                "problem_id": str(incident_data["problem_id"]) if incident_data.get("problem_id") else None,
                "incident_number": new_number,
                "title": incident_data["title"],
                "description": incident_data["description"],
                "category": incident_data.get("category"),
                "client_id": client_id,
                "affected_ci_id": ci_id,
                "severity": incident_data["severity"],
                "impact": incident_data["impact"],
                "urgency": incident_data["urgency"],
                "status": incident_data.get("status", "open"),
                "reported_by": reported_by,
                "assigned_to": str(incident_data["assigned_to"]) if incident_data.get("assigned_to") else None,
                "detection_time": incident_data["detection_time"],
                "acknowledged_at": incident_data.get("acknowledged_at"),
                "resolved_at": incident_data.get("resolved_at"),
                "closed_at": incident_data.get("closed_at"),
                "created_at": timestamp,
                "updated_at": timestamp
            }

            incidents[new_id] = new_incident
            save_incidents(incidents)
            return json.dumps(new_incident)

        # ---------------- UPDATE ----------------
        elif action == "update":
            if not incident_id:
                return json.dumps({"success": False, "error": "incident_id is required for update action"})

            incident_id = str(incident_id).strip()
            if incident_id.startswith('"') and incident_id.endswith('"'):
                incident_id = incident_id[1:-1]

            if incident_id not in incidents:
                return json.dumps({"success": False, "error": f"Incident with ID '{incident_id}' not found"})

            if not incident_data:
                return json.dumps({"success": False, "error": "incident_data is required for update action"})

            current_incident = incidents[incident_id]
            updated_incident = current_incident.copy()

            for key, value in incident_data.items():
                updated_incident[key] = value

            updated_incident["updated_at"] = timestamp
            incidents[incident_id] = updated_incident
            save_incidents(incidents)
            return json.dumps(updated_incident)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_incidents",
                "description": "Create or update incident records with file persistence under envs/incident_management_redo/data/incidents.json.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {"type": "string", "enum": ["create", "update"]},
                        "incident_id": {"type": "string"},
                        "incident_data": {"type": "object"}
                    },
                    "required": ["action"]
                }
            }
        }
import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManagePerformanceMetrics(Tool):
    """
    Create and update performance metrics for incident management KPIs.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        metric_id: Optional[str] = None,
        incident_id: Optional[str] = None,
        metric_type: Optional[str] = None,
        calculated_value_minutes: Optional[int] = None,
        sla_target_minutes: Optional[int] = None,
        recorded_by: Optional[str] = None,
    ) -> str:
        """
        Create or update performance metric records for incident management KPIs.

        Actions:
        - create: Create new performance metric (requires incident_id, metric_type, calculated_value_minutes, recorded_by)
        - update: Update existing performance metric (requires metric_id and at least one field to update)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        timestamp = "2025-10-01T12:00:00"
        metrics = data.get("performance_metrics", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        valid_metric_types = ["MTTA", "MTTD", "MTTR", "MTTM", "FTR"]
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "update" and not metric_id:
            return json.dumps({
                "success": False,
                "error": "metric_id is required for update action"
            })

        if action == "create":
            if not all([incident_id, metric_type, calculated_value_minutes is not None, recorded_by]):
                return json.dumps({
                    "success": False,
                    "error": "incident_id, metric_type, calculated_value_minutes, and recorded_by are required for create action"
                })

            # Validate incident exists
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident with ID {incident_id} not found"
                })

            # Validate user exists and is active
            if recorded_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {recorded_by} not found"
                })
            if users[recorded_by]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {recorded_by} is not active"
                })

            if metric_type not in valid_metric_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid metric_type. Must be one of: {', '.join(valid_metric_types)}"
                })

            if calculated_value_minutes < 0:
                return json.dumps({
                    "success": False,
                    "error": "calculated_value_minutes cannot be negative"
                })

            if sla_target_minutes is not None and sla_target_minutes < 0:
                return json.dumps({
                    "success": False,
                    "error": "sla_target_minutes cannot be negative"
                })

            new_id = generate_id(metrics)
            new_metric = {
                "metric_id": new_id,
                "incident_id": incident_id,
                "metric_type": metric_type,
                "calculated_value_minutes": calculated_value_minutes,
                "sla_target_minutes": sla_target_minutes,
                "recorded_by": recorded_by,
                "recorded_date": timestamp,
                "created_at": timestamp,
                "updated_at": timestamp
            }
            metrics[new_id] = new_metric

            return json.dumps({
                "success": True,
                "action": "create",
                "metric_id": new_id,
                "metric_data": new_metric
            })

        if action == "update":
            if metric_id not in metrics:
                return json.dumps({
                    "success": False,
                    "error": f"Metric with ID {metric_id} not found"
                })

            # Validate at least one field is being updated
            if all(v is None for v in [metric_type, calculated_value_minutes, sla_target_minutes, recorded_by]):
                return json.dumps({
                    "success": False,
                    "error": "At least one field must be provided for update"
                })

            existing_metric = metrics[metric_id]

            if recorded_by is not None:
                if recorded_by not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {recorded_by} not found"
                    })
                if users[recorded_by]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {recorded_by} is not active"
                    })

            if metric_type is not None:
                if metric_type not in valid_metric_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid metric_type. Must be one of: {', '.join(valid_metric_types)}"
                    })
                existing_metric["metric_type"] = metric_type

            if calculated_value_minutes is not None:
                if calculated_value_minutes < 0:
                    return json.dumps({
                        "success": False,
                        "error": "calculated_value_minutes cannot be negative"
                    })
                existing_metric["calculated_value_minutes"] = calculated_value_minutes

            if sla_target_minutes is not None:
                if sla_target_minutes < 0:
                    return json.dumps({
                        "success": False,
                        "error": "sla_target_minutes cannot be negative"
                    })
                existing_metric["sla_target_minutes"] = sla_target_minutes

            if recorded_by is not None:
                existing_metric["recorded_by"] = recorded_by
                existing_metric["recorded_date"] = timestamp

            existing_metric["updated_at"] = timestamp

            return json.dumps({
                "success": True,
                "action": "update",
                "metric_id": metric_id,
                "metric_data": existing_metric
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns comprehensive information about the tool's capabilities, parameters, and data schema.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_performance_metrics",
                "description": "Create/update performance metrics for incident management KPIs (MTTA, MTTD, MTTR, MTTM, FTR). Actions: 'create' (requires incident_id, metric_type, calculated_value_minutes, recorded_by; optional: sla_target_minutes), 'update' (requires metric_id; optional: metric_type, calculated_value_minutes, sla_target_minutes, recorded_by).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "metric_id": {
                            "type": "string",
                            "description": "Required for update. ID of the metric to update"
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "Required for create. ID of the incident this metric belongs to"
                        },
                        "metric_type": {
                            "type": "string",
                            "description": "Type of performance metric: MTTA (Mean Time To Acknowledge), MTTD (Mean Time To Detect), MTTR (Mean Time To Resolve), MTTM (Mean Time To Mitigate), FTR (First Time Resolution Rate)",
                            "enum": ["MTTA", "MTTD", "MTTR", "MTTM", "FTR"]
                        },
                        "calculated_value_minutes": {
                            "type": "integer",
                            "description": "Actual measured value of the metric in minutes (must be non-negative)"
                        },
                        "sla_target_minutes": {
                            "type": "integer",
                            "description": "Optional. Target value according to SLA in minutes (must be non-negative)"
                        },
                        "recorded_by": {
                            "type": "string",
                            "description": "ID of the active user recording the metric"
                        }
                    },
                    "required": ["action"]
                }
            }
        }import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManagePostIncidentReviews(Tool):
    """
    Create and update post-incident reviews for incident analysis and improvement.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        review_id: Optional[str] = None,
        incident_id: Optional[str] = None,
        reviewer_id: Optional[str] = None,
        review_type: Optional[str] = None,
        review_findings: Optional[str] = None,
        impact_assessment: Optional[str] = None,
        root_causes: Optional[list] = None,
        lessons_learned: Optional[str] = None,
        recommendations: Optional[str] = None,
        action_items: Optional[list] = None
    ) -> str:
        """
        Create or update post-incident review records.

        Actions:
        - create: Create new review (requires incident_id, reviewer_id, review_type, review_findings)
        - update: Update existing review (requires review_id and at least one field to update)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        def generate_review_number(review_id: str) -> str:
            """Generate a formatted review number."""
            return f"PIR{review_id.zfill(8)}"

        timestamp = "2025-10-01T12:00:00"
        reviews = data.get("post_incident_reviews", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        valid_review_types = ["Preliminary", "Detailed", "Final"]
        valid_statuses = ["Draft", "In_Review", "Approved", "Published"]
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "update" and not review_id:
            return json.dumps({
                "success": False,
                "error": "review_id is required for update action"
            })

        if action == "create":
            if not all([incident_id, reviewer_id, review_type, review_findings]):
                return json.dumps({
                    "success": False,
                    "error": "incident_id, reviewer_id, review_type, and review_findings are required for create action"
                })

            # Validate incident exists
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident with ID {incident_id} not found"
                })

            # Validate user exists and is active
            if reviewer_id not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {reviewer_id} not found"
                })
            if users[reviewer_id]["status"] != "active":
                return json.dumps({
                    "success": False,
                    "error": f"User with ID {reviewer_id} is not active"
                })

            if review_type not in valid_review_types:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid review_type. Must be one of: {', '.join(valid_review_types)}"
                })

            if not review_findings.strip():
                return json.dumps({
                    "success": False,
                    "error": "review_findings cannot be empty"
                })

            new_id = generate_id(reviews)
            review_number = generate_review_number(new_id)
            new_review = {
                "review_id": new_id,
                "review_number": review_number,
                "incident_id": incident_id,
                "reviewer_id": reviewer_id,
                "review_type": review_type,
                "review_findings": review_findings,
                "impact_assessment": impact_assessment.strip() if impact_assessment else None,
                "root_causes": root_causes if root_causes else [],
                "lessons_learned": lessons_learned.strip() if lessons_learned else None,
                "recommendations": recommendations.strip() if recommendations else None,
                "action_items": action_items if action_items else [],
                "review_status": "Draft",
                "created_at": timestamp,
                "updated_at": timestamp,
                "last_modified_by": reviewer_id,
                "version": 1,
                "contributors": [reviewer_id]
            }
            reviews[new_id] = new_review

            return json.dumps({
                "success": True,
                "action": "create",
                "review_id": new_id,
                "review_number": review_number,
                "review_data": new_review
            })

        if action == "update":
            if review_id not in reviews:
                return json.dumps({
                    "success": False,
                    "error": f"Review with ID {review_id} not found"
                })

            # Validate at least one field is being updated
            update_fields = [
                review_type, review_findings, impact_assessment,
                root_causes, lessons_learned, recommendations, action_items
            ]
            if all(v is None for v in update_fields):
                return json.dumps({
                    "success": False,
                    "error": "At least one field must be provided for update"
                })

            existing_review = reviews[review_id]

            if reviewer_id is not None:
                if reviewer_id not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {reviewer_id} not found"
                    })
                if users[reviewer_id]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {reviewer_id} is not active"
                    })

            if review_type is not None:
                if review_type not in valid_review_types:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid review_type. Must be one of: {', '.join(valid_review_types)}"
                    })
                existing_review["review_type"] = review_type

            if review_findings is not None:
                if not review_findings.strip():
                    return json.dumps({
                        "success": False,
                        "error": "review_findings cannot be empty"
                    })
                existing_review["review_findings"] = review_findings.strip()
                existing_review["version"] += 1

            if impact_assessment is not None:
                existing_review["impact_assessment"] = impact_assessment.strip()

            if root_causes is not None:
                existing_review["root_causes"] = root_causes

            if lessons_learned is not None:
                existing_review["lessons_learned"] = lessons_learned.strip()

            if recommendations is not None:
                existing_review["recommendations"] = recommendations.strip()

            if action_items is not None:
                existing_review["action_items"] = action_items

            if reviewer_id is not None:
                existing_review["last_modified_by"] = reviewer_id
                if reviewer_id not in existing_review["contributors"]:
                    existing_review["contributors"].append(reviewer_id)

            existing_review["updated_at"] = timestamp

            return json.dumps({
                "success": True,
                "action": "update",
                "review_id": review_id,
                "review_number": existing_review["review_number"],
                "review_data": existing_review
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns comprehensive information about the tool's capabilities, parameters, and data schema.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_post_incident_reviews",
                "description": "Create/update post-incident reviews for formal analysis of incidents and identification of improvements. Actions: 'create' (requires incident_id, reviewer_id, review_type, review_findings; optional: impact_assessment, root_causes, lessons_learned, recommendations, action_items), 'update' (requires review_id; optional: review_type, review_findings, impact_assessment, root_causes, lessons_learned, recommendations, action_items, reviewer_id).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "review_id": {
                            "type": "string",
                            "description": "Required for update. ID of the review to update"
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "Required for create. ID of the incident being reviewed"
                        },
                        "reviewer_id": {
                            "type": "string",
                            "description": "ID of the active primary reviewer"
                        },
                        "review_type": {
                            "type": "string",
                            "description": "Type of review: Preliminary (initial quick review), Detailed (comprehensive analysis), Final (complete review)",
                            "enum": ["Preliminary", "Detailed", "Final"]
                        },
                        "review_findings": {
                            "type": "string",
                            "description": "Primary findings and observations from the review (must not be empty)"
                        },
                        "impact_assessment": {
                            "type": "string",
                            "description": "Analysis of incident's impact on business, users, and systems"
                        },
                        "root_causes": {
                            "type": "array",
                            "description": "List of identified root causes (array of strings)",
                            "items": {"type": "string"}
                        },
                        "lessons_learned": {
                            "type": "string",
                            "description": "Key learnings and insights from the incident"
                        },
                        "recommendations": {
                            "type": "string",
                            "description": "Suggested improvements and preventive measures"
                        },
                        "action_items": {
                            "type": "array",
                            "description": "List of specific tasks to implement recommendations",
                            "items": {"type": "object"}
                        }
                    },
                    "required": ["action"]
                }
            }
        }import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ManageRootCauseAnalyses(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], action: str, rca_data: Dict[str, Any] = None, rca_id: str = None) -> str:
        """
        Conduct (create) or update root cause analysis records.
        
        Actions:
        - conduct: Create new RCA (requires incident_id, rca_title, assigned_to, due_date, status)
        - update: Update existing RCA (requires rca_id and fields to update)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        def generate_rca_number(rca_id: int) -> str:
            return f"RCA{str(rca_id).zfill(7)}"
        
        if action not in ["conduct", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'conduct' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        # get existing data tables
        root_cause_analyses = data.get("root_cause_analyses", {})
        incidents = data.get("incidents", {})
        users = data.get("users", {})

        # allowed enums
        valid_methods = ["5_whys", "fishbone", "timeline", "fault_tree", "kepner_tregoe"]
        valid_statuses = ["assigned", "in_progress", "completed", "approved"]

        # allowed values
        required_incident_statuses = ["resolved", "closed"]
        required_incident_severity = ["P1", "P2"]
        required_user_status = ["active"]
        

        # for conduct action
        if action == "conduct":
            if not rca_data:
                return json.dumps({
                    "success": False,
                    "error": "rca_data is required for conduct action"
                })

            # Validate required fields
            required_fields = ["incident_id", "rca_title", "assigned_to", "due_date"]

            missing_fields = [field for field in required_fields if field not in rca_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Missing required fields for conduct action: {', '.join(missing_fields)}"
                })
            
            # Allowed fields
            allowed_fields = ["rca_title", "incident_id", "assigned_to", "analysis_method", "root_cause_summary", "status", "due_date"]

            rca_fields = [field for field in rca_data if field not in allowed_fields]
            if rca_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Unrecognized fields in rca_data: {', '.join(rca_fields)}"
                })
            
            # Validate that incident exists
            if str(rca_data["incident_id"]) not in incidents:
                return json.dumps({
                    "success": False,
                    "error": "Halt: Incident not found"
                })
            
            # Validate that incident status is resolved or closed
            incident_status = incidents[str(rca_data["incident_id"])]["status"]
            if incident_status not in required_incident_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Incident status must be one of: {', '.join(required_incident_statuses)}"
                })
            
            # Validate that incident severity is P1 or P2
            incident_severity = incidents[str(rca_data["incident_id"])]["severity"]
            if incident_severity not in required_incident_severity:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Incident severity must be one of: {', '.join(required_incident_severity)}"
                })
            
            # Validate that assigned_to user exists
            if str(rca_data["assigned_to"]) not in users:
                return json.dumps({
                    "success": False,
                    "error": "Halt: User assigned_to not found"
                })
            
            # Validate that assigned_to user is active
            if users[str(rca_data["assigned_to"])]["status"] not in required_user_status: 
                return json.dumps({ 
                    "success": False, 
                    "error": "Halt: User assigned_to must be active" 
                })
            
            # Validate rca_title is not empty
            title = rca_data.get("rca_title")
            if not title or not title.strip():  
                return json.dumps({
                    "success": False,
                    "error": "Halt: rca_title cannot be empty"
                })
            
            # Validate status
            status = rca_data.get("status", "assigned")
            if status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                })
            
            # Validate analysis_method if provided
            analysis_method = rca_data.get("analysis_method")
            if analysis_method and analysis_method not in valid_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid analysis method - must be one of: {', '.join(valid_methods)}"
                })
            
            # Generate new RCA ID
            new_rca_id = generate_id(root_cause_analyses)
            rca_number = generate_rca_number(new_rca_id)
            
            # Create new RCA record
            new_rca = {
                "rca_id": str(new_rca_id),
                "rca_number": str(rca_number),
                "rca_title": rca_data["rca_title"],
                "incident_id": str(rca_data["incident_id"]),
                "assigned_to": str(rca_data["assigned_to"]),
                "analysis_method": analysis_method if analysis_method else None,
                "root_cause_summary": rca_data["root_cause_summary"] if "root_cause_summary" in rca_data else None,
                "status": status,
                "due_date": rca_data["due_date"],
                "completed_at": rca_data["completed_at"] if "completed_at" in rca_data else None,
                "approved_by": str(rca_data["approved_by"]) if "approved_by" in rca_data else None,
                "created_at": "2025-10-07T00:00:00",
                "updated_at": "2025-10-07T00:00:00"
            }
            
            root_cause_analyses[str(new_rca_id)] = new_rca
            
            return json.dumps({
                "success": True,
                "action": "conduct",
                "rca_id": str(new_rca_id),
                "message": f"RCA {new_rca_id} created successfully",
                "rca_data": new_rca
            })
        

        # for update action
        elif action == "update":
            if not rca_id:
                return json.dumps({
                    "success": False,
                    "error": "Halt: rca_id is required for update action"
                })
            
            if str(rca_id) not in root_cause_analyses:
                return json.dumps({
                    "success": False,
                    "error": "Halt: RCA not found"
                })
            
            if not rca_data:
                return json.dumps({
                    "success": False,
                    "error": "rca_data is required for conduct action"
                })
            
            # Validate at least one optional field is provided
            update_fields = ["rca_title", "assigned_to", "analysis_method", "root_cause_summary", "status", "due_date", "completed_at", "approved_by"]

            provided_fields = [field for field in update_fields if field in rca_data]
            if not provided_fields:
                return json.dumps({
                    "success": False,
                    "error": f"At least one optional field must be provided for updates {', '.join(update_fields)}"
                })
            
            # Validate only allowed fields for updates
            invalid_fields = [field for field in rca_data.keys() if field not in update_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields for RCA updating: {', '.join(invalid_fields)}"
                })
            
            # Validate rca_title is not empty if provided
            if "rca_title" in rca_data:
                if not str(rca_data["rca_title"]).strip():  
                    return json.dumps({
                        "success": False,
                        "error": "Halt: rca_title cannot be empty"
                    })
            
            if "assigned_to" in rca_data:
                # Validate that assigned_to user exists if provided
                if str(rca_data["assigned_to"]) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User assigned_to not found"
                    })

                # Validate that assigned_to user is active if provided
                if users[str(rca_data["assigned_to"])]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User assigned_to must be active" 
                    })
            
            # Validate analysis_method if provided
            analysis_method = rca_data.get("analysis_method")
            if analysis_method and analysis_method not in valid_methods:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid analysis method - must be one of: {', '.join(valid_methods)}"
                })
            
            # Validate status if provided
            status = rca_data.get("status")
            if status and status not in valid_statuses:
                return json.dumps({
                    "success": False,
                    "error": f"Halt: Invalid status - must be one of: {', '.join(valid_statuses)}"
                })
            
            approved_by = rca_data.get("approved_by")
            if approved_by:  
                # Validate that approved_by user exists if provided
                if str(approved_by) not in users:
                    return json.dumps({
                        "success": False,
                        "error": "Halt: User approved_by not found"
                    })
            
                # Validate that approved_by user is active if provided
                if users[str(approved_by)]["status"] not in required_user_status: 
                    return json.dumps({ 
                        "success": False, 
                        "error": "Halt: User approved_by must be active" 
                    })
            
            # If status is approved, approved_by is required
            if status == "approved" and not approved_by:
                return json.dumps({
                    "success": False,
                    "error": "Halt: approved_by is required when status is approved"
                })
            
            # Get current RCA record
            current_rca = root_cause_analyses[str(rca_id)]
            # Update RCA record with modified information
            updated_rca = current_rca.copy()
            for key, value in rca_data.items():
                if key in ["analysis_method", "root_cause_summary", "completed_at", "approved_by"]:
                    updated_rca[key] = str(value) if value not in (None, "") else None
                else:
                    updated_rca[key] = value
            
            updated_rca["updated_at"] = "2025-10-07T00:00:00"

            root_cause_analyses[str(rca_id)] = updated_rca
            
            return json.dumps({
                "success": True,
                "action": "update",
                "rca_id": str(rca_id),
                "message": f"RCA {rca_id} updated successfully",
                "rca_data": updated_rca
            })
        
        
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_root_cause_analyses",
                "description": "Conduct or update root cause analysis records in the incident management system. This tool manages RCA lifecycle including creation, progress tracking, and completion. For Conducting: establishes new RCA with incident linkage, analyst assignment, and due date. For updates: modifies RCA details, status transitions, and approval tracking. Validates incident/user existence, enforces status transitions (assigned, in_progress, completed, approved), validates analysis methods, and ensures approval requirements. Essential for post-incident investigation, continuous improvement, and compliance with ITIL best practices.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'conduct' to establish new RCA, 'update' to modify existing RCA",
                            "enum": ["conduct", "update"]
                        },
                        "rca_data": {
                            "type": "object",
                            "description": "Data for conducting or updating the RCA record",
                            "properties": {
                                "rca_title": {
                                    "type": "string",
                                    "description": "Title of the root cause analysis (required for conduct)"
                                },
                                "incident_id": {
                                    "type": "string",
                                    "description": "Related incident identifier (required for conduct)"
                                },
                                "assigned_to": {
                                    "type": "string",
                                    "description": "User identifier conducting the analysis (required for conduct, must exist in system)"
                                },
                                "due_date": {
                                    "type": "string",
                                    "description": "Date by which analysis should be completed in YYYY-MM-DD format (required for conduct)"
                                },
                                "analysis_method": {
                                    "type": "string",
                                    "description": "Analysis methodology used (optional for conduct): 5_whys, fishbone, timeline, fault_tree, kepner_tregoe",
                                    "enum": ["5_whys", "fishbone", "timeline", "fault_tree", "kepner_tregoe"]
                                },
                                "root_cause_summary": {
                                    "type": "string",
                                    "description": "Summary of identified root cause (optional for conduct)"
                                },
                                "status": {
                                    "type": "string",
                                    "description": "RCA status (optional for conduct): assigned, in_progress, completed, approved",
                                    "enum": ["assigned", "in_progress", "completed", "approved"]
                                },
                                "completed_at": {
                                    "type": "string",
                                    "description": "Timestamp when analysis was completed in YYYY-MM-DDTHH:MM:SS format"
                                },
                                "approved_by": {
                                    "type": "string",
                                    "description": "User identifier who approved the analysis (required when status is approved)"
                                }
                            }
                        },
                        "rca_id": {
                            "type": "string",
                            "description": "Unique identifier of the RCA (required for update action)"
                        }
                    },
                    "required": ["action"]
                }
            }
        }
import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageUsers(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        user_data: Optional[Dict[str, Any]] = None,
        user_id: Optional[str] = None
    ) -> str:
        """
        Create or update user records.
        
        Actions:
        - create: Create new user record (requires user_data with first_name, last_name, email, role, timezone)
        - update: Update existing user record (requires user_id and user_data with changes)
        """
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        timestamp = "2025-10-01T00:00:00"
        
        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })
        
        if not isinstance(data, dict):
            return json.dumps({
                "success": False,
                "error": "Invalid data format"
            })
        
        users = data.get("users", {})
        clients = data.get("clients", {})
        vendors = data.get("vendors", {})
        
        if action == "create":
            if not user_data:
                return json.dumps({
                    "success": False,
                    "error": "user_data is required for create action"
                })
            
            # Validate required fields
            required_fields = ["first_name", "last_name", "email", "role", "timezone"]
            missing_fields = [field for field in required_fields if field not in user_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })
            
            # Validate allowed fields
            allowed_fields = ["first_name", "last_name", "email", "role", "timezone", "status", "client_id", "vendor_id"]
            invalid_fields = [field for field in user_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate role enum
            valid_roles = ["incident_manager", "technical_support", "account_manager", "executive", "vendor_contact", "system_administrator", "client_contact"]
            if user_data["role"] not in valid_roles:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid role '{user_data['role']}'. Must be one of: {', '.join(valid_roles)}"
                })
            
            # Validate status enum if provided
            if "status" in user_data:
                valid_status = ["active", "inactive", "suspended"]
                if user_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status '{user_data['status']}'. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Check email uniqueness
            for user in users.values():
                if user.get("email") == user_data["email"]:
                    return json.dumps({
                        "success": False,
                        "error": "Email already exists"
                    })
            
            # Validate client_id if role is client_contact
            if user_data["role"] == "client_contact":
                if "client_id" not in user_data:
                    return json.dumps({
                        "success": False,
                        "error": "client_id is required for client_contact role"
                    })
                if user_data["client_id"] not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
            
            # Validate vendor_id if role is vendor_contact
            if user_data["role"] == "vendor_contact":
                if "vendor_id" not in user_data:
                    return json.dumps({
                        "success": False,
                        "error": "vendor_id is required for vendor_contact role"
                    })
                if user_data["vendor_id"] not in vendors:
                    return json.dumps({
                        "success": False,
                        "error": "Vendor not found"
                    })
            
            # Create new user
            new_id = str(generate_id(users))
            new_user = {
                "user_id": new_id,
                "first_name": user_data["first_name"],
                "last_name": user_data["last_name"],
                "email": user_data["email"],
                "role": user_data["role"],
                "timezone": user_data["timezone"],
                "status": user_data.get("status", "active"),
                "client_id": user_data.get("client_id"),
                "vendor_id": user_data.get("vendor_id"),
                "created_at": timestamp,
                "updated_at": timestamp
            }
            users[new_id] = new_user
            
            return json.dumps({
                "success": True,
                "action": "create",
                "user_id": new_id,
                "user_data": new_user
            })
        
        elif action == "update":
            if not user_id:
                return json.dumps({
                    "success": False,
                    "error": "user_id is required for update action"
                })
            
            if user_id not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User {user_id} not found"
                })
            
            if not user_data:
                return json.dumps({
                    "success": False,
                    "error": "user_data is required for update action"
                })
            
            # Validate allowed fields
            allowed_fields = ["first_name", "last_name", "email", "role", "timezone", "status", "client_id", "vendor_id"]
            invalid_fields = [field for field in user_data.keys() if field not in allowed_fields]
            if invalid_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid fields: {', '.join(invalid_fields)}"
                })
            
            # Validate role enum if provided
            if "role" in user_data:
                valid_roles = ["incident_manager", "technical_support", "account_manager", "executive", "vendor_contact", "system_administrator", "client_contact"]
                if user_data["role"] not in valid_roles:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid role. Must be one of: {', '.join(valid_roles)}"
                    })
            
            # Validate status enum if provided
            if "status" in user_data:
                valid_status = ["active", "inactive", "suspended"]
                if user_data["status"] not in valid_status:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_status)}"
                    })
            
            # Check email uniqueness if being updated
            if "email" in user_data:
                for uid, user in users.items():
                    if uid != user_id and user.get("email") == user_data["email"]:
                        return json.dumps({
                            "success": False,
                            "error": "New email already exists"
                        })
            
            # Get current user to check role
            current_user = users[user_id]
            current_role = user_data.get("role", current_user.get("role"))
            
            # Validate client_id if role is client_contact
            if current_role == "client_contact" and "client_id" in user_data:
                if user_data["client_id"] not in clients:
                    return json.dumps({
                        "success": False,
                        "error": "Client not found"
                    })
            
            # Validate vendor_id if role is vendor_contact
            if current_role == "vendor_contact" and "vendor_id" in user_data:
                if user_data["vendor_id"] not in vendors:
                    return json.dumps({
                        "success": False,
                        "error": "Vendor not found"
                    })
            
            # Update user
            updated_user = users[user_id].copy()
            for key, value in user_data.items():
                updated_user[key] = value
            updated_user["updated_at"] = timestamp
            users[user_id] = updated_user
            
            return json.dumps({
                "success": True,
                "action": "update",
                "user_id": user_id,
                "user_data": updated_user
            })
    
    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_users",
                "description": "Create or update user records in the incident management system. For creation, establishes new user records with comprehensive validation including role-based requirements. For updates, modifies existing user records while maintaining data integrity. Validates user roles, status values, and associated client/vendor relationships according to system requirements.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' to establish new user record, 'update' to modify existing user record",
                            "enum": ["create", "update"]
                        },
                        "user_data": {
                            "type": "object",
                            "description": "User data object. For create: requires first_name, last_name, email (must be unique), role ('incident_manager', 'technical_support', 'account_manager', 'executive', 'vendor_contact', 'system_administrator', 'client_contact'), timezone, with optional status ('active', 'inactive', 'suspended'), client_id (required for client_contact role), vendor_id (required for vendor_contact role). For update: includes user fields to change. SYNTAX: {\"key\": \"value\"}"
                        },
                        "user_id": {
                            "type": "string",
                            "description": "Unique identifier of the user record. Required for update action only."
                        }
                    },
                    "required": ["action"]
                }
            }
        }
import json
import os
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool


class ManageWorkNotes(Tool):
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        note_id: Optional[str] = None,
        note_data: Optional[Dict[str, Any]] = None,
    ) -> str:
        def generate_id(table: Dict[str, Any]) -> str:
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        TOOL_DIR = os.path.dirname(os.path.abspath(__file__))
        ENV_DIR = os.path.dirname(TOOL_DIR)
        DATA_DIR = os.path.join(ENV_DIR, "data")
        WORK_NOTES_FP = os.path.join(DATA_DIR, "work_notes.json")

        def ensure_dirs() -> None:
            os.makedirs(DATA_DIR, exist_ok=True)

        def load_work_notes() -> Dict[str, Any]:
            if os.path.exists(WORK_NOTES_FP):
                try:
                    with open(WORK_NOTES_FP, "r") as f:
                        return json.load(f)
                except Exception:
                    return {}
            return {}

        def save_work_notes(notes_dict: Dict[str, Any]) -> None:
            ensure_dirs()
            with open(WORK_NOTES_FP, "w") as f:
                json.dump(notes_dict, f, indent=2)

        timestamp = "2025-11-01T00:00:00"
        work_notes = data.setdefault("work_notes", {})
        incidents = data.setdefault("incidents", {})
        users = data.setdefault("users", {})

        if not work_notes:
            loaded = load_work_notes()
            if loaded:
                work_notes.update(loaded)

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": f"Invalid action '{action}'. Must be 'create' or 'update'"
            })

        if action == "create":
            if not note_data:
                return json.dumps({
                    "success": False,
                    "error": "note_data is required for create action"
                })

            required_fields = ["incident_id", "note_text", "created_by"]
            missing_fields = [field for field in required_fields if field not in note_data]
            if missing_fields:
                return json.dumps({
                    "success": False,
                    "error": f"Missing required fields: {', '.join(missing_fields)}"
                })

            incident_id = str(note_data["incident_id"])
            if incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident with ID '{incident_id}' not found"
                })

            created_by = str(note_data["created_by"])
            if created_by not in users:
                return json.dumps({
                    "success": False,
                    "error": f"User with ID '{created_by}' not found"
                })

            if not isinstance(note_data.get("note_text"), str) or not note_data["note_text"].strip():
                return json.dumps({
                    "success": False,
                    "error": "note_text must be a non-empty string"
                })

            new_note_id = generate_id(work_notes)
            new_work_note = {
                "note_id": new_note_id,
                "incident_id": incident_id,
                "note_text": note_data["note_text"],
                "created_by": created_by,
                "created_at": timestamp,
                "updated_at": timestamp
            }

            work_notes[new_note_id] = new_work_note
            save_work_notes(work_notes)
            return json.dumps(new_work_note)

        if not note_id:
            return json.dumps({
                "success": False,
                "error": "note_id is required for update action"
            })

        if note_id not in work_notes:
            return json.dumps({
                "success": False,
                "error": f"Work note with ID '{note_id}' not found"
            })

        if not note_data:
            return json.dumps({
                "success": False,
                "error": "note_data is required for update action"
            })

        if "note_text" not in note_data:
            return json.dumps({
                "success": False,
                "error": "Only note_text can be updated"
            })

        if not isinstance(note_data["note_text"], str) or not note_data["note_text"].strip():
            return json.dumps({
                "success": False,
                "error": "note_text must be a non-empty string"
            })

        current_work_note = work_notes[note_id]
        updated_work_note = current_work_note.copy()
        updated_work_note["note_text"] = note_data["note_text"]
        updated_work_note["updated_at"] = timestamp
        work_notes[note_id] = updated_work_note
        save_work_notes(work_notes)
        return json.dumps(updated_work_note)

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "manage_work_notes",
                "description": (
                    "Create or update work note records in the incident management system. "
                    "This tool manages work notes with file persistence under data/work_notes.json. "
                    "For creation, establishes new notes linked to incidents with proper validation of user and incident existence. "
                    "For updates, modifies existing work notes (only note_text can be changed)."
                ),
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": (
                                "Action to perform:\n"
                                "- 'create': Add a new work note (requires note_data with incident_id, note_text, created_by)\n"
                                "- 'update': Modify an existing note (requires note_id and note_data with new note_text)"
                            ),
                            "enum": ["create", "update"]
                        },
                        "note_id": {
                            "type": "string",
                            "description": (
                                "Unique identifier of the work note. Required only for 'update' action. "
                                "Use the note_id returned by the create action when updating."
                            )
                        },
                        "note_data": {
                            "type": "object",
                            "description": (
                                "Work note data object.\n\n"
                                "For 'create': requires the following fields:\n"
                                "  - incident_id: ID of the linked incident (must exist in incidents)\n"
                                "  - note_text: the content of the work note\n"
                                "  - created_by: user ID of the author (must exist in users)\n\n"
                                "For 'update': only note_text is required.\n\n"
                                "Examples:\n"
                                "- Create: {\"incident_id\": \"1\", \"note_text\": \"Restarted service\", \"created_by\": \"100\"}\n"
                                "- Update: {\"note_text\": \"Issue resolved and verified\"}"
                            ),
                            "properties": {
                                "incident_id": {
                                    "type": "string",
                                    "description": "Incident identifier (required for create, must exist in system)"
                                },
                                "note_text": {
                                    "type": "string",
                                    "description": "Content of the work note (required for create and update)"
                                },
                                "created_by": {
                                    "type": "string",
                                    "description": "User ID who created the note (required for create, must exist in users)"
                                }
                            }
                        }
                    },
                    "required": ["action"]
                }
            }
        }
import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class ManageWorkOrders(Tool):
    """
    Create and update work orders for incidents and changes.
    """
    @staticmethod
    def invoke(
        data: Dict[str, Any],
        action: str,
        work_order_id: Optional[str] = None,
        change_id: Optional[str] = None,
        incident_id: Optional[str] = None,
        title: Optional[str] = None,
        description: Optional[str] = None,
        assigned_to: Optional[str] = None,
        status: Optional[str] = None,
        scheduled_date: Optional[str] = None,
        priority: Optional[str] = None,
        created_by: Optional[str] = None
    ) -> str:
        """
        Create or update work order records.

        Actions:
        - create: Create new work order (requires title, description, assigned_to)
        - update: Update existing work order (requires work_order_id and at least one field to update)
        """
        def generate_id(table: Dict[str, Any]) -> str:
            """Generates a new unique ID for a record."""
            if not table:
                return "1"
            return str(max(int(k) for k in table.keys()) + 1)

        def generate_work_order_number(order_id: str) -> str:
            """Generate a formatted work order number."""
            return f"WO{order_id.zfill(8)}"

        timestamp = "2025-10-01T12:00:00"
        work_orders = data.get("work_orders", {})
        incidents = data.get("incidents", {})
        changes = data.get("change_requests", {})
        users = data.get("users", {})

        valid_statuses = ["pending", "in_progress", "on_hold", "completed", "cancelled"]
        valid_priorities = ["low", "medium", "high", "critical", "emergency"]

        if action not in ["create", "update"]:
            return json.dumps({
                "success": False,
                "error": "Invalid action. Must be 'create' or 'update'"
            })

        if action == "update" and not work_order_id:
            return json.dumps({
                "success": False,
                "error": "work_order_id is required for update action"
            })

        if action == "create":
            # Validate required fields
            if not all([title, description, assigned_to, created_by]):
                return json.dumps({
                    "success": False,
                    "error": "title, description, assigned_to, and created_by are required for create action"
                })

            # Validate users exist and are active
            for user_id in [assigned_to, created_by]:
                if user_id not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {user_id} not found"
                    })
                if users[user_id]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {user_id} is not active"
                    })

            # Validate title and description
            if not title.strip():
                return json.dumps({
                    "success": False,
                    "error": "title cannot be empty"
                })
            if not description.strip():
                return json.dumps({
                    "success": False,
                    "error": "description cannot be empty"
                })

            # Validate related records if provided
            if incident_id and incident_id not in incidents:
                return json.dumps({
                    "success": False,
                    "error": f"Incident with ID {incident_id} not found"
                })
            if change_id and change_id not in changes:
                return json.dumps({
                    "success": False,
                    "error": f"Change request with ID {change_id} not found"
                })

            # Validate priority if provided
            if priority and priority not in valid_priorities:
                return json.dumps({
                    "success": False,
                    "error": f"Invalid priority. Must be one of: {', '.join(valid_priorities)}"
                })

            new_id = generate_id(work_orders)
            work_order_number = generate_work_order_number(new_id)
            new_order = {
                "work_order_id": new_id,
                "work_order_number": work_order_number,
                "change_id": change_id,
                "incident_id": incident_id,
                "title": title.strip(),
                "description": description.strip(),
                "assigned_to": assigned_to,
                "created_by": created_by,
                "status": status or "pending",
                "priority": priority or "medium",
                "scheduled_date": scheduled_date,
                "completed_at": None,
                "created_at": timestamp,
                "updated_at": timestamp,
                "last_modified_by": created_by,
                "version": 1,
                "history": [{
                    "timestamp": timestamp,
                    "action": "created",
                    "user_id": created_by,
                    "details": "Work order created"
                }]
            }
            work_orders[new_id] = new_order

            return json.dumps({
                "success": True,
                "action": "create",
                "work_order_id": new_id,
                "work_order_number": work_order_number,
                "work_order_data": new_order
            })

        if action == "update":
            if work_order_id not in work_orders:
                return json.dumps({
                    "success": False,
                    "error": f"Work order with ID {work_order_id} not found"
                })

            # Validate at least one field is being updated
            update_fields = [title, description, assigned_to, status, scheduled_date, priority]
            if all(v is None for v in update_fields):
                return json.dumps({
                    "success": False,
                    "error": "At least one field must be provided for update"
                })

            existing_order = work_orders[work_order_id]

            # Validate users if being updated
            if assigned_to is not None:
                if assigned_to not in users:
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {assigned_to} not found"
                    })
                if users[assigned_to]["status"] != "active":
                    return json.dumps({
                        "success": False,
                        "error": f"User with ID {assigned_to} is not active"
                    })

            history_entry = {
                "timestamp": timestamp,
                "action": "updated",
                "user_id": created_by or assigned_to,
                "changes": []
            }

            if title is not None:
                if not title.strip():
                    return json.dumps({
                        "success": False,
                        "error": "title cannot be empty"
                    })
                history_entry["changes"].append({"field": "title", "old": existing_order["title"], "new": title.strip()})
                existing_order["title"] = title.strip()

            if description is not None:
                if not description.strip():
                    return json.dumps({
                        "success": False,
                        "error": "description cannot be empty"
                    })
                history_entry["changes"].append({"field": "description", "old": existing_order["description"], "new": description.strip()})
                existing_order["description"] = description.strip()

            if assigned_to is not None:
                history_entry["changes"].append({"field": "assigned_to", "old": existing_order["assigned_to"], "new": assigned_to})
                existing_order["assigned_to"] = assigned_to

            if status is not None:
                if status not in valid_statuses:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid status. Must be one of: {', '.join(valid_statuses)}"
                    })
                history_entry["changes"].append({"field": "status", "old": existing_order["status"], "new": status})
                existing_order["status"] = status
                if status == "completed":
                    existing_order["completed_at"] = timestamp

            if priority is not None:
                if priority not in valid_priorities:
                    return json.dumps({
                        "success": False,
                        "error": f"Invalid priority. Must be one of: {', '.join(valid_priorities)}"
                    })
                history_entry["changes"].append({"field": "priority", "old": existing_order["priority"], "new": priority})
                existing_order["priority"] = priority

            if scheduled_date is not None:
                history_entry["changes"].append({"field": "scheduled_date", "old": existing_order["scheduled_date"], "new": scheduled_date})
                existing_order["scheduled_date"] = scheduled_date

            existing_order["updated_at"] = timestamp
            existing_order["last_modified_by"] = created_by or assigned_to
            existing_order["version"] += 1
            existing_order["history"].append(history_entry)

            return json.dumps({
                "success": True,
                "action": "update",
                "work_order_id": work_order_id,
                "work_order_number": existing_order["work_order_number"],
                "work_order_data": existing_order
            })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        """
        Returns comprehensive information about the tool's capabilities, parameters, and data schema.
        """
        return {
            "type": "function",
            "function": {
                "name": "manage_work_orders",
                "description": "Create/update work orders for incidents and changes. Actions: 'create' (requires title, description, assigned_to, created_by; optional: change_id, incident_id, status, priority, scheduled_date), 'update' (requires work_order_id; optional: title, description, assigned_to, status, priority, scheduled_date).",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "action": {
                            "type": "string",
                            "description": "Action to perform: 'create' or 'update'",
                            "enum": ["create", "update"]
                        },
                        "work_order_id": {
                            "type": "string",
                            "description": "Required for update. ID of the work order to update"
                        },
                        "change_id": {
                            "type": "string",
                            "description": "Optional. ID of the related change request"
                        },
                        "incident_id": {
                            "type": "string",
                            "description": "Optional. ID of the related incident"
                        },
                        "title": {
                            "type": "string",
                            "description": "Brief title describing the work to be done (must not be empty)"
                        },
                        "description": {
                            "type": "string",
                            "description": "Detailed description of the work order (must not be empty)"
                        },
                        "assigned_to": {
                            "type": "string",
                            "description": "ID of the active user assigned to complete the work"
                        },
                        "status": {
                            "type": "string",
                            "description": "Status: pending, in_progress, on_hold, completed, cancelled",
                            "enum": ["pending", "in_progress", "on_hold", "completed", "cancelled"]
                        },
                        "scheduled_date": {
                            "type": "string",
                            "description": "Planned date/time for the work (ISO format)"
                        },
                        "priority": {
                            "type": "string",
                            "description": "Priority level",
                            "enum": ["low", "medium", "high", "critical", "emergency"]
                        },
                        "created_by": {
                            "type": "string",
                            "description": "Required for create. ID of the user creating the work order"
                        }
                    },
                    "required": ["action"]
                }
            }
        }