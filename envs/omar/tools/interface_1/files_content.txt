import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CalculateFutureValue(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], closing_price_or_nav: float, growth_rate: float, 
               number_of_years: int) -> str:
        
        # Validate inputs
        if closing_price_or_nav <= 0:
            return json.dumps({"success": False, "message": "Closing price or NAV must be positive", "halt": True})
        
        if number_of_years < 0:
            return json.dumps({"success": False, "message": "Number of years must be non-negative", "halt": True})
        
        # Calculate future value using formula: FV = PV * (1 + r)^n
        future_value = round(closing_price_or_nav * ((1 + growth_rate) ** number_of_years), 4)
        
        return json.dumps({"future_value": future_value})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "calculate_future_value",
                "description": "Calculate future value using compound interest formula",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "closing_price_or_nav": {"type": "number", "description": "Closing price of fund or NAV"},
                        "growth_rate": {"type": "number", "description": "Growth rate 'r'"},
                        "number_of_years": {"type": "integer", "description": "Number of years 'n'"}
                    },
                    "required": ["closing_price_or_nav", "growth_rate", "number_of_years"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CalculateLiabilities(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_id: str) -> str:
        instrument_prices = data.get('instrument_prices', {})
        
        # Find the most recent instrument price record by instrument_id
        instrument_price = None
        latest_date = None
        
        for price_record in instrument_prices.values():
            if str(price_record.get('instrument_id')) == str(instrument_id):
                record_date = price_record.get('price_date')
                if record_date and (latest_date is None or record_date > latest_date):
                    latest_date = record_date
                    instrument_price = price_record
        
        if instrument_price is None:
            return json.dumps({"success": False, "message": "Instrument not found"})
        
        # Get the closing price (note: field name is 'close_price' not 'closing_price')
        closing_price = instrument_price.get('close_price', 0)
        
        # Validate closing price
        if closing_price <= 0:
            return json.dumps({"success": False, "message": "Instrument closing price must be positive"})
        
        # Calculate liabilities as 1.5% of closing price
        liabilities = round(closing_price * 0.015, 4)

        return json.dumps({"success": True, "liabilities": liabilities, "price_date": latest_date})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "calculate_liabilities",
                "description": "Calculate liabilities as 1.5% of instrument closing price",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_id": {"type": "string", "description": "ID of the instrument"}
                    },
                    "required": ["instrument_id"]
                }
            }
        }import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CalculateNav(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, calculation_date: str) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        funds = data.get("funds", {})
        nav_records = data.get("nav_records", {})
        trades = data.get("trades", {})
        instrument_prices = data.get("instrument_prices", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found", "halt": True})
        
        fund = funds[str(fund_id)]
        
        # Calculate NAV based on fund size and recent trades
        base_nav = float(fund.get("size", 1000000))  # Use fund size as base
        
        # Adjust based on recent trades for this fund
        trade_adjustments = 0
        for trade in trades.values():
            if trade.get("fund_id") == fund_id and trade.get("status") == "executed":
                trade_value = float(trade.get("quantity", 0)) * float(trade.get("price", 0))
                if trade.get("side") == "buy":
                    trade_adjustments += trade_value
                else:
                    trade_adjustments -= trade_value
        
        # Simple NAV calculation: base + 5% growth + trade adjustments
        nav_value = round(base_nav * 1.05 + trade_adjustments, 4)
        
        # Create or update NAV record
        nav_id = generate_id(nav_records)
        timestamp = "2025-10-01T00:00:00"
        
        new_nav_record = {
            "nav_id": nav_id,
            "fund_id": fund_id,
            "nav_date": calculation_date,
            "nav_value": nav_value,
            "updated_at": timestamp
        }
        
        nav_records[str(nav_id)] = new_nav_record
        
        return json.dumps({"nav_value": nav_value, "success": True, "message": "NAV updated"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "calculate_nav",
                "description": "Calculate and update the Net Asset Value 'NAV' for a fund",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "calculation_date": {"type": "string", "description": "Date for NAV calculation"}
                    },
                    "required": ["fund_id", "calculation_date"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CancelSubscription(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], subscription_id: str) -> str:
        
        subscriptions = data.get("subscriptions", {})
        
        # Validate subscription exists
        if str(subscription_id) not in subscriptions:
            return json.dumps({"error": f"Subscription {subscription_id} not found"})
        
        subscription = subscriptions[str(subscription_id)]
        timestamp = "2025-10-01T00:00:00"
        
        # Update subscription status
        subscription["status"] = "cancelled"
        subscription["updated_at"] = timestamp
        
        return json.dumps({"success": True, "message": "Cancellation complete"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "cancel_subscription",
                "description": "Cancel a subscription",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "subscription_id": {"type": "string", "description": "ID of the subscription to cancel"},
                    },
                    "required": ["subscription_id"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateCommitment(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, fund_id: str, 
               amount: float, due_date: str, compliance_officer_approval: bool) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        investors = data.get("investors", {})
        funds = data.get("funds", {})
        commitments = data.get("commitments", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            return json.dumps({"success": False, "message": "Investor not found"})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found"})
        
        # Validate compliance approval
        if not compliance_officer_approval:
            return json.dumps({"success": False, "message": "Compliance officer approval required"})
        
        # Validate amount
        if amount <= 0:
            return json.dumps({"success": False, "message": "Amount must be positive"})
        
        commitment_id = generate_id(commitments)
        timestamp = "2025-10-01T00:00:00"
        
        new_commitment = {
            "commitment_id": commitment_id,
            "fund_id": fund_id,
            "investor_id": investor_id,
            "commitment_amount": amount,
            "commitment_date": due_date,
            "status": "pending", # Initial status and the status can be updated later to fulfilled
            "updated_at": timestamp
        }
        
        commitments[str(commitment_id)] = new_commitment
        return json.dumps({"commitment_id": str(commitment_id), "success": True, "status": "Pending"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_commitment",
                "description": "Create a new commitment for an investor to a fund",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "amount": {"type": "number", "description": "Commitment amount"},
                        "due_date": {"type": "string", "description": "Due date for the commitment"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"}
                    },
                    "required": ["investor_id", "fund_id", "amount", "due_date", "compliance_officer_approval"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateFund(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_name: str, fund_type: str,
               initial_size: float, manager_id: str, 
               compliance_officer_review: bool, fund_manager_approval: bool) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if not compliance_officer_review:
            return json.dumps({"error": "Compliance Officer review required. Process halted."})
        
        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        
        funds = data.get("funds", {})
        users = data.get("users", {})
        
        # Validate manager exists
        if str(manager_id) not in users:
            return json.dumps({"error": f"Manager {manager_id} not found"})
        
        # Validate fund type
        valid_types = ["mutual_funds", "exchange_traded_funds", "pension_funds", "private_equity_funds",
                      "hedge_funds", "sovereign_wealth_funds", "money_market_funds", 
                      "real_estate_investment_trusts", "infrastructure_funds", "multi_asset_funds"]
        if fund_type not in valid_types:
            return json.dumps({"error": f"Invalid fund type. Must be one of {valid_types}"})
        
        fund_id = generate_id(funds)
        timestamp = "2025-10-01T00:00:00"
        
        new_fund = {
            "fund_id": fund_id,
            "name": fund_name,
            "fund_type": fund_type,
            "manager_id": int(manager_id),
            "size": initial_size,
            "status": "open", # status can be open, closed, or suspended
            "created_at": timestamp,
            "updated_at": timestamp
        }
        
        funds[str(fund_id)] = new_fund
        return json.dumps({"fund_id": str(fund_id)})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_fund",
                "description": "Create a new fund after approvals",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_name": {"type": "string", "description": "Name of the fund"},
                        "fund_type": {"type": "string", "description": "Type of fund. Must be one of: 'mutual_funds', 'exchange_traded_funds', 'pension_funds', 'private_equity_funds', 'hedge_funds', 'sovereign_wealth_funds', 'money_market_funds', 'real_estate_investment_trusts', 'infrastructure_funds', 'multi_asset_funds'"},
                        "initial_size": {"type": "number", "description": "Initial size of the fund"},
                        "manager_id": {"type": "string", "description": "ID of the fund manager"},
                        "compliance_officer_review": {"type": "boolean", "description": "Compliance Officer review flag (True/False)"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag (True/False)"}
                    },
                    "required": ["fund_name", "fund_type", "initial_size", "manager_id", 
                            "compliance_officer_review", "fund_manager_approval"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateSubscription(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, fund_id: str, amount: float,
               compliance_officer_approval: bool) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        # if not compliance_officer_approval:
        #     return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        investors = data.get("investors", {})
        funds = data.get("funds", {})
        subscriptions = data.get("subscriptions", {})
        
        # Validate entities exist
        if str(investor_id) not in investors:
            return json.dumps({"error": f"Investor {investor_id} not found"})
        if str(fund_id) not in funds:
            return json.dumps({"error": f"Fund {fund_id} not found"})
        
        # Check if fund is open
        if funds[str(fund_id)].get("status") != "open":
            return json.dumps({"error": "Fund is not open for subscriptions"})
        
        subscription_id = generate_id(subscriptions)
        timestamp = "2025-10-01T00:00:00"
        
        # Determine status based on payment details
        status = "pending" if not compliance_officer_approval else "approved"
        
        new_subscription = {
            "subscription_id": subscription_id,
            "fund_id": int(fund_id),
            "investor_id": int(investor_id),
            "amount": amount,
            "status": status,
            "request_assigned_to": 1,  # Default admin
            "request_date": timestamp.split("T")[0],
            "approval_date": timestamp.split("T")[0] if status == "approved" else None,
            "updated_at": timestamp
        }
        
        subscriptions[str(subscription_id)] = new_subscription
        
        return_status = "active" if status == "approved" else "funds_pending"
        return json.dumps({"new_subscription": new_subscription, "status": return_status})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_subscription",
                "description": "Create a new fund subscription",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "amount": {"type": "number", "description": "Subscription amount"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"}
                    },
                    "required": ["investor_id", "fund_id", "amount", "compliance_officer_approval"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class CreateUploadDocument(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], user_id: str, 
               size_bytes: int, confidentiality_level: str, file_name: str, 
               file_format: str, report_id: str = None) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        users = data.get("users", {})
        documents = data.get("documents", {})
        
        # Validate user exists
        if str(user_id) not in users:
            return json.dumps({"success": False, "message": "User not found"})
        
        # Validate file format
        valid_formats = ["pdf", "docx", "xlsx", "csv"]
        if file_format.lower() not in valid_formats:
            return json.dumps({"success": False, "message": f"Invalid file format. Must be one of {valid_formats}"})
        
        # Validate confidentiality level
        valid_levels = ["public", "internal", "confidential", "restricted"]
        if confidentiality_level.lower() not in valid_levels:
            return json.dumps({"success": False, "message": f"Invalid confidentiality level. Must be one of {valid_levels}"})
        
        document_id = generate_id(documents)
        timestamp = "2025-10-01T00:00:00"
        
        new_document = {
            "document_id": document_id,
            "name": file_name,
            "type": file_format.lower(),
            "uploaded_by": user_id,
            "upload_date": timestamp,
            "report_id": report_id,
            "size_bytes": size_bytes,
            "status": "available"
        }
        
        documents[str(document_id)] = new_document
        return json.dumps({"doc_id": str(document_id), "status": "available"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "create_upload_document",
                "description": "Create and upload a document to the system",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "user_id": {"type": "string", "description": "ID of the user uploading the document"},
                        "size_bytes": {"type": "integer", "description": "Size of document in bytes"},
                        "confidentiality_level": {"type": "string", "description": "Confidentiality levels: 'public', 'internal', 'confidential', 'restricted'"},
                        "file_name": {"type": "string", "description": "Name of the file"},
                        "file_format": {"type": "string", "description": "File format: pdf, docx, xlsx, or csv"}
                    },
                    "required": ["user_id", "size_bytes", "confidentiality_level", "file_name", "file_format"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class DeactivateReactivateInstrument(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_id: str, action: str,
               fund_manager_approval: bool, compliance_officer_approval: bool) -> str:
        
        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        instruments = data.get("instruments", {})
        
        # Validate instrument exists
        if str(instrument_id) not in instruments:
            return json.dumps({"error": f"Instrument {instrument_id} not found"})
        
        # Validate action
        if action not in ["deactivate", "reactivate"]:
            return json.dumps({"error": "Action must be 'deactivate' or 'reactivate'"})
        
        instrument = instruments[str(instrument_id)]
        
        # Update instrument status
        if action == "deactivate":
            instrument["status"] = "inactive"
            message = "Instrument Deactivated"
        else:
            instrument["status"] = "active"
            message = "Instrument Reactivated"
        
        return json.dumps({
            "success": True, 
            "message": message,
            "instrument_id": str(instrument_id)
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "deactivate_reactivate_instrument",
                "description": "Deactivate or reactivate an instrument",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_id": {"type": "string", "description": "ID of the instrument"},
                        "action": {"type": "string", "description": "Action to perform (deactivate or reactivate)"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag (True/False)"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"}
                    },
                    "required": ["instrument_id", "action", "fund_manager_approval", "compliance_officer_approval"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class DeleteFund(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, compliance_officer_approval: bool,
               fund_manager_approval: bool) -> str:
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        
        funds = data.get("funds", {})
        subscriptions = data.get("subscriptions", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"error": f"Fund {fund_id} not found"})
        
        # Check for active subscriptions
        active_subscriptions = [s for s in subscriptions.values() 
                            if s.get("fund_id") == int(fund_id) and s.get("status") == "approved"]
        
        # if active_subscriptions:
        #     return json.dumps({"error": "Cannot delete fund with active subscriptions. Process halted."})
        
        # Delete fund
        del funds[str(fund_id)]
        
        return json.dumps({"success": True, "message": "Fund deleted"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "delete_fund",
                "description": "Delete a fund after required approvals",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund to delete"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag (True/False)"}
                    },
                    "required": ["fund_id", "compliance_officer_approval", "fund_manager_approval"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ExecuteTrade(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, instrument_id: str,
               quantity: float, price_limit: float, trader_id: str,
               fund_manager_approval: bool) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        

        funds = data.get("funds", {})
        users = data.get("users", {})
        trades = data.get("trades", {})
        instruments = data.get("instruments", {})
        
        # Validate entities exist
        if str(fund_id) not in funds:
            return json.dumps({"error": f"Fund {fund_id} not found"})
        if str(trader_id) not in users:
            return json.dumps({"error": f"Trader {trader_id} not found"})
        if str(instrument_id) not in instruments:
            return json.dumps({"error": f"Instrument {instrument_id} not found"})
        
        trade_id = generate_id(trades)
        timestamp = "2025-10-01T00:00:00"
        
        # Determine trade side
        side = "buy" if quantity > 0 else "sell"
        
        new_trade = {
            "trade_id": trade_id,
            "fund_id": int(fund_id),
            "instrument_id": int(instrument_id),
            "trade_date": timestamp,
            "quantity": abs(quantity),
            "price": price_limit,
            "side": side,
            "status": "executed",
            "created_at": timestamp
        }
        
        trades[str(trade_id)] = new_trade
        
        return json.dumps({"trade_id": str(trade_id), "success": True, "message": "Trade executed"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "execute_trade",
                "description": "Execute a trade after required approvals",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "instrument_id": {"type": "string", "description": "ID of the instrument to trade"},
                        "quantity": {"type": "number", "description": "Trade quantity: positive for buy, negative for sell"},
                        "price_limit": {"type": "number", "description": "Price limit"},
                        "trader_id": {"type": "string", "description": "ID of the trader"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag (True/False)"}
                    },
                    "required": ["fund_id", "instrument_id", "quantity", "price_limit", "trader_id", 
                               "fund_manager_approval"]
                }
            }
        }import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class FulfillCommitment(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], commitment_id: str, payment_receipt_amount: float, 
               payment_date: str, payment_method: str) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        commitments = data.get("commitments", {})
        invoices = data.get("invoices", {})
        payments = data.get("payments", {})
        
        # Validate commitment exists
        if str(commitment_id) not in commitments:
            return json.dumps({"success": False, "message": "Commitment not found", "halt": True})
        
        commitment = commitments[str(commitment_id)]
        
        # Validate payment method
        valid_methods = ["wire", "cheque", "credit_card", "bank_transfer"]
        if payment_method.lower() not in valid_methods:
            return json.dumps({"success": False, "message": f"Invalid payment method. Must be one of {valid_methods}", "halt": True})
        
        # Validate amount
        if payment_receipt_amount <= 0:
            return json.dumps({"success": False, "message": "Payment amount must be positive", "halt": True})
        
        # Create invoice if not exists
        invoice_id = None
        for inv_id, inv in invoices.items():
            if inv.get("commitment_id") == commitment_id:
                invoice_id = inv_id
                break
        
        if not invoice_id:
            invoice_id = generate_id(invoices)
            new_invoice = {
                "invoice_id": invoice_id,
                "commitment_id": commitment_id,
                "invoice_date": payment_date,
                "due_date": payment_date,
                "amount": commitment["commitment_amount"],
                "status": "issued",
                "updated_at": "2025-10-01T00:00:00"
            }
            invoices[str(invoice_id)] = new_invoice
        
        # Create payment record
        payment_id = generate_id(payments)
        timestamp = "2025-10-01T00:00:00"
        
        new_payment = {
            "payment_id": payment_id,
            "invoice_id": str(invoice_id),
            "payment_date": timestamp,
            "amount": payment_receipt_amount,
            "payment_method": payment_method.lower(),
            "status": "completed",
            "created_at": timestamp
        }
        
        payments[str(payment_id)] = new_payment
        
        # Update commitment status
        if payment_receipt_amount >= commitment["commitment_amount"]:
            commitment["status"] = "fulfilled"
            status = "fulfilled"
        else:
            status = "pending"
        
        commitment["updated_at"] = timestamp
        
        # Update invoice status if payment covers full amount
        if payment_receipt_amount >= invoices[str(invoice_id)]["amount"]:
            invoices[str(invoice_id)]["status"] = "paid"
            invoices[str(invoice_id)]["updated_at"] = timestamp
        
        return json.dumps({
            "commitment_id": commitment_id, 
            "success": True, 
            "status": status, 
            "amount": payment_receipt_amount
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "fulfill_commitment",
                "description": "Fulfill a commitment by recording payment receipt",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "commitment_id": {"type": "string", "description": "ID of the commitment"},
                        "payment_receipt_amount": {"type": "number", "description": "Amount received"},
                        "payment_date": {"type": "string", "description": "Date of payment (YYYY-MM-DD)"},
                        "payment_method": {"type": "string", "description": "Method of payment: wire, cheque, credit_card, bank_transfer"}
                    },
                    "required": ["commitment_id", "payment_receipt_amount", "payment_date", "payment_method"]
                }
            }
        }
import json
from typing import Any, Dict, Optional, Tuple
from datetime import datetime
import calendar
import re
from tau_bench.envs.tool import Tool


class GenerateReport(Tool):

    @staticmethod
    def invoke(data: Dict[str, Any], report_type: str, period: str, 
               requester_role: str, fund_id: Optional[str] = None, 
               investor_id: Optional[str] = None) -> str:

        def _parse_period(period: str) -> Tuple[str, str]:
            """Parse reporting period into start_date and end_date (YYYY-MM-DD)."""
            period = str(period).strip().upper() # enforce the period to be a string and uppercase

            # Yearly: "2025"
            if re.fullmatch(r"\d{4}", period):
                year = int(period)
                return f"{year}-01-01", f"{year}-12-31"

            # Monthly: "2025-07"
            if re.fullmatch(r"\d{4}-\d{2}", period):
                year, month = map(int, period.split("-"))
                last_day = calendar.monthrange(year, month)[1]
                return f"{year}-{month:02d}-01", f"{year}-{month:02d}-{last_day}"

            # Snapshot: "2025-10-01"
            if re.fullmatch(r"\d{4}-\d{2}-\d{2}", period):
                return period, period

            # Quarterly: "Q1-2025"
            if re.fullmatch(r"Q[1-4]-\d{4}", period):
                q, year = period.split("-")
                year = int(year)
                q = int(q[1])
                month_start = (q - 1) * 3 + 1
                month_end = month_start + 2
                last_day = calendar.monthrange(year, month_end)[1]
                return f"{year}-{month_start:02d}-01", f"{year}-{month_end:02d}-{last_day}"

            # Half-year: "H1-2025" or "H2-2025"
            if re.fullmatch(r"H[12]-\d{4}", period):
                h, year = period.split("-")
                year = int(year)
                if h == "H1":
                    return f"{year}-01-01", f"{year}-06-30"
                else:
                    return f"{year}-07-01", f"{year}-12-31"

            raise ValueError(f"Unsupported period format: {period}")
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        reports = data.get("reports", {})
        funds = data.get("funds", {})
        investors = data.get("investors", {})
        users = data.get("users", {})
        
        # Validate report type
        valid_types = ["performance", "financial", "holding"]
        report_type = report_type.lower()
        if report_type not in valid_types:
            return json.dumps({"success": False, "message": f"Invalid report type. Must be one of {valid_types}"})
        
        # Map each report type to the allowed role
        role_permissions = {
            "performance": "fund_manager",
            "financial": "finance_officer",
            "holding": "finance_officer"
        }
        
        expected_role = role_permissions[report_type]
        if requester_role.lower() != expected_role:
            return json.dumps({
                "success": False,
                "message": f"{report_type.capitalize()} report can only be generated by a {expected_role}"
            })
        
        # If fund_id provided, validate it exists
        if fund_id and str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found"})
        
        # If investor_id provided, validate it exists
        if investor_id and str(investor_id) not in investors:
            return json.dumps({"success": False, "message": "Investor not found"})
        
        # Find a user with the appropriate role to be the generator
        generated_by = None
        for user_id, user in users.items():
            if user.get("role") == requester_role.lower():
                generated_by = user_id
                break
        
        if not generated_by:
            return json.dumps({"success": False, "message": "No authorized user found to generate report"})
        
        try:
            start_date, end_date = _parse_period(period)
        except ValueError as e:
            return json.dumps({"success": False, "message": str(e)})
        
        report_id = generate_id(reports)
        # timestamp = datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%S")
        timestamp = "2025-10-01T00:00:00"
        # Set fund_id to first available fund if not specified and needed
        if not fund_id and funds:
            fund_id = list(funds.keys())[0]
        
        new_report = {
            "report_id": report_id,
            "fund_id": fund_id,
            "investor_id": investor_id,
            "report_type": report_type,
            "report_start": start_date,
            "report_end": end_date,
            "generated_by": generated_by,
            "status": "completed",
            "created_at": timestamp
        }
        
        reports[str(report_id)] = new_report
        
        return json.dumps({"created_report": new_report})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "generate_report",
                "description": "Generate a report for funds or investors",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "report_type": {"type": "string", "description": "Type of report: performance, financial, holding"},
                        "fund_id": {"type": "string", "description": "ID of the fund 'optional'"},
                        "investor_id": {"type": "string", "description": "ID of the investor 'optional'"},
                        "period": {"type": "string", "description": "Reporting period (YYYY, YYYY-MM, YYYY-MM-DD, Qn-YYYY, Hn-YYYY)"},
                        "requester_role": {"type": "string", "description": "Role of the person requesting the report. The person can be fund_manager or a finance_officer"}
                    },
                    "required": ["report_type", "period", "requester_role"]
                }
            }
        }

import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class GetFundInstruments(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str) -> str:
        funds = data.get("funds", {})
        instruments = data.get("instruments", {})
        trades = data.get("trades", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found", "halt": True})
        
        fund_instruments = []
        for trade_id, trade in trades.items():
            if trade.get("fund_id") == fund_id:
                instrument_id = trade.get("instrument_id")
                fund_instruments.append(instruments.get(str(instrument_id), {}))
        
        return json.dumps({"fund_instruments": fund_instruments})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "get_fund_instruments",
                "description": "Retrieve all instruments associated with a specific fund",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund"}
                    },
                    "required": ["fund_id"]
                }
            }
        }import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class InvestorOffboarding(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str,
               compliance_officer_approval: bool) -> str:
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        investors = data.get("investors", {})
        subscriptions = data.get("subscriptions", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            return json.dumps({"error": f"Investor {investor_id} not found"})
        
        # Check for active subscriptions
        active_subscriptions = [s for s in subscriptions.values() 
                              if s.get("investor_id") == int(investor_id) and s.get("status") == "approved"]
        
        if active_subscriptions:
            return json.dumps({"error": "Cannot offboard investor with active subscriptions. Process halted."})
        
        # Remove investor (in practice, might just mark as inactive)
        del investors[str(investor_id)]
        
        return json.dumps({"message": "Offboarding complete"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "investor_offboarding",
                "description": "Offboard an investor after compliance approval",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor to offboard"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval for offboarding"}
                    },
                    "required": ["investor_id", "compliance_officer_approval"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class InvestorOnboarding(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], legal_entity_name: str, incorporation_registration_number: str,
               date_of_incorporation: str, country_of_incorporation: str, registered_business_address: str,
               tax_identification_number: str, source_of_funds_declaration: str, compliance_officer_approval: bool) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        investors = data.get("investors", {})
        
        # Validate source of funds
        valid_sources = ["retained_earnings", "shareholder_capital", "asset_sale", "loan_facility", 
                        "external_investment", "government_grant", "merger_or_acquisition_proceeds",
                        "royalty_or_licensing_income", "dividend_income", "other"]
        if source_of_funds_declaration not in valid_sources:
            return json.dumps({"error": f"Invalid source of funds. Must be one of {valid_sources}"})
        
        investor_id = generate_id(investors)
        timestamp = "2025-10-01T00:00:00"
        
        new_investor = {
            "investor_id": investor_id,
            "name": legal_entity_name,
            "registration_number": incorporation_registration_number,
            "date_of_incorporation": date_of_incorporation,
            "country": country_of_incorporation,
            "address": registered_business_address,
            "tax_id": tax_identification_number,
            "source_of_funds": source_of_funds_declaration,
            "contact_email": "",  # Will need to be provided separately
            "accreditation_status": "accredited",  # Default for institutional investors
            "created_at": timestamp
        }
        
        investors[str(investor_id)] = new_investor
        return json.dumps({"investor_id": str(investor_id)})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "investor_onboarding",
                "description": "Onboard a new institutional investor after compliance checks",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "legal_entity_name": {"type": "string", "description": "Legal entity name"},
                        "incorporation_registration_number": {"type": "string", "description": "Incorporation/registration number"},
                        "date_of_incorporation": {"type": "string", "description": "Date of incorporation (YYYY-MM-DD)"},
                        "country_of_incorporation": {"type": "string", "description": "Country of incorporation"},
                        "registered_business_address": {"type": "string", "description": "Registered business address"},
                        "tax_identification_number": {"type": "string", "description": "Tax identification number"},
                        "source_of_funds_declaration": {"type": "string", "description": "Source of funds declaration. It should be only one of the following: 'retained_earnings', 'shareholder_capital', 'asset_sale', 'loan_facility', 'external_investment', 'government_grant', 'merger_or_acquisition_proceeds', 'royalty_or_licensing_income', 'dividend_income', 'other'"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"}
                    },
                    "required": ["legal_entity_name", "incorporation_registration_number", "date_of_incorporation", 
                               "country_of_incorporation", "registered_business_address", "tax_identification_number",
                               "source_of_funds_declaration", "compliance_officer_approval"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class ProcessRedemption(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, fund_id: str, 
               amount_or_units: float, compliance_approval: bool, 
               finance_approval: bool) -> str:

        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        investors = data.get("investors", {})
        funds = data.get("funds", {})
        subscriptions = data.get("subscriptions", {})
        redemptions = data.get("redemptions", {})
        portfolios = data.get("portfolios", {})
        portfolio_holdings = data.get("portfolio_holdings", {})
        
        # Validate investor exists
        if str(investor_id) not in investors:
            return json.dumps({"success": False, "message": "Investor not found"})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"success": False, "message": "Fund not found"})
        
        # Check if fund is open
        if funds[str(fund_id)].get("status") != "open":
            return json.dumps({"success": False, "message": "Fund is not open for redemptions"})
        
        # Validate approvals
        if not compliance_approval or not finance_approval:
            return json.dumps({"success": False, "message": "Required approvals not obtained"})
        
        # Find ALL subscriptions and calculate total (OPTION 1)
        all_subscription_ids = []
        all_subscriptions = []
        total_subscription_amount = 0

        for sub_id, sub in subscriptions.items():
            if (sub.get("investor_id") == investor_id and 
                sub.get("fund_id") == fund_id and 
                sub.get("status") == "approved"):
                all_subscription_ids.append(sub.get("subscription_id"))
                all_subscriptions.append(sub)
                total_subscription_amount += float(sub.get("amount", 0))

        if not all_subscription_ids:
            return json.dumps({"success": False, "message": "No active subscription found for this investor and fund"})

        # Check existing redemptions against ALL subscriptions
        total_redeemed = 0
        for redemption in redemptions.values():
            if (redemption.get("subscription_id") in all_subscription_ids and
                redemption.get("status") in ["approved", "processed"]):
                total_redeemed += float(redemption.get("redemption_amount", 0))
        
        # Calculate available balance
        available_balance = total_subscription_amount - total_redeemed
        
        # Validate sufficient balance
        if available_balance < amount_or_units:
            return json.dumps({
                "success": False, 
                "message": f"Insufficient balance. Available: {available_balance}, Requested: {amount_or_units}"
            })
        
        # Additional validation: Check portfolio holdings if they exist
        investor_portfolio = None
        for portfolio in portfolios.values():
            if portfolio.get("investor_id") == investor_id:
                investor_portfolio = portfolio
                break
        
        if investor_portfolio:
            # Check portfolio holdings for this fund
            fund_holdings = 0
            for holding in portfolio_holdings.values():
                if (holding.get("portfolio_id") == investor_portfolio.get("portfolio_id") and
                    holding.get("fund_id") == fund_id):
                    fund_holdings += float(holding.get("quantity", 0))
            
            # Validate against portfolio holdings if they exist
            if fund_holdings > 0 and fund_holdings < amount_or_units:
                return json.dumps({
                    "success": False, 
                    "message": f"Insufficient holdings in portfolio. Available: {fund_holdings}, Requested: {amount_or_units}"
                })
        
        redemption_id = generate_id(redemptions)
        timestamp = "2025-10-01T00:00:00"
        
        # Use the first subscription for the redemption record (or you could choose differently)
        primary_subscription = all_subscriptions[0]
        
        new_redemption = {
            "redemption_id": redemption_id,
            "subscription_id": primary_subscription.get("subscription_id"),
            "request_date": "2025-10-01",
            "redemption_amount": amount_or_units,
            "status": "approved",
            "processed_date": "2025-10-01",
            "updated_at": timestamp,
            "redemption_fee": round(amount_or_units * 0.01, 2)  # 1% fee
        }
        
        redemptions[str(redemption_id)] = new_redemption
        
        # Update portfolio holdings if they exist
        if investor_portfolio:
            for holding_id, holding in portfolio_holdings.items():
                if (holding.get("portfolio_id") == investor_portfolio.get("portfolio_id") and
                    holding.get("fund_id") == fund_id):
                    # Reduce the holding quantity
                    current_quantity = float(holding.get("quantity", 0))
                    new_quantity = max(0, current_quantity - amount_or_units)
                    holding["quantity"] = new_quantity
                    break
        
        return json.dumps({
            "success": True, 
            "message": "Redemption processed",
            "redemption_id": redemption_id,
            "remaining_balance": available_balance - amount_or_units,
            "debug_info": {
                "total_subscriptions_found": len(all_subscription_ids),
                "total_subscription_amount": total_subscription_amount,
                "total_redeemed_before": total_redeemed,
                "available_balance_before": available_balance
            }
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "process_redemption",
                "description": "Process a redemption request for an investor with balance validation across all subscriptions",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "fund_id": {"type": "string", "description": "ID of the fund"},
                        "amount_or_units": {"type": "number", "description": "Amount or units to redeem"},
                        "compliance_approval": {"type": "boolean", "description": "Compliance approval flag (True for approved/False for rejected)"},
                        "finance_approval": {"type": "boolean", "description": "Finance approval flag (True for approved/False for rejected)"}
                    },
                    "required": ["investor_id", "fund_id", "amount_or_units", "compliance_approval", "finance_approval"]
                }
            }
        }import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class SwitchFunds(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], investor_id: str, current_fund_id: str,
               target_fund_id: str, switch_amount: float) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        funds = data.get("funds", {})
        investors = data.get("investors", {})
        subscriptions = data.get("subscriptions", {})
        redemptions = data.get("redemptions", {})
        
        # Validate entities exist
        if str(investor_id) not in investors:
            return json.dumps({"error": f"Investor {investor_id} not found"})
        if str(current_fund_id) not in funds:
            return json.dumps({"error": f"Current fund {current_fund_id} not found"})
        if str(target_fund_id) not in funds:
            return json.dumps({"error": f"Target fund {target_fund_id} not found"})
        
        # Find current subscription
        current_subscription = None
        for sub in subscriptions.values():
            if (sub.get("investor_id") == (investor_id) and # compare a string with string
                sub.get("fund_id") == (current_fund_id) and 
                sub.get("status") == "approved"):
                current_subscription = sub
                break
        
        if not current_subscription:
            return json.dumps({"error": "No active subscription for this investor found in current fund"})
        
        if current_subscription.get("amount", 0) < switch_amount:
            return json.dumps({"error": "Insufficient balance in current fund"})
        
        timestamp = "2025-10-01T00:00:00"
        
        # Create redemption from current fund
        redemption_id = generate_id(redemptions)
        new_redemption = {
            "redemption_id": redemption_id,
            "subscription_id": current_subscription["subscription_id"],
            "request_date": timestamp.split("T")[0],
            "redemption_amount": switch_amount,
            "status": "processed",
            "processed_date": timestamp.split("T")[0],
            "updated_at": timestamp,
            "redemption_fee": 0.0
        }
        redemptions[str(redemption_id)] = new_redemption
        
        # Update current subscription
        current_subscription["amount"] -= switch_amount
        current_subscription["updated_at"] = timestamp
        
        # Create new subscription in target fund
        subscription_id = generate_id(subscriptions)
        new_subscription = {
            "subscription_id": subscription_id,
            "fund_id": int(target_fund_id),
            "investor_id": int(investor_id),
            "amount": switch_amount,
            "status": "approved",
            "request_assigned_to": 1,  # Default admin
            "request_date": timestamp.split("T")[0],
            "approval_date": timestamp.split("T")[0],
            "updated_at": timestamp
        }
        subscriptions[str(subscription_id)] = new_subscription
        
        return json.dumps({"success": True, "message": "Switch complete"})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "switch_funds",
                "description": "Switch investor funds between two funds",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "investor_id": {"type": "string", "description": "ID of the investor"},
                        "current_fund_id": {"type": "string", "description": "ID of the current fund"},
                        "target_fund_id": {"type": "string", "description": "ID of the target fund"},
                        "switch_amount": {"type": "number", "description": "Amount to switch"}
                    },
                    "required": ["investor_id", "current_fund_id", "target_fund_id", "switch_amount"]
                }
            }
        }
import json
from typing import Any, Dict, Optional, Union
from tau_bench.envs.tool import Tool

class UpdateFund(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], fund_id: str, field_name: str, field_value: Union[str, int, float],
               fund_manager_approval: bool, compliance_review_required: Optional[bool] = None,
               compliance_officer_approval: Optional[bool] = None) -> str:

        if not fund_manager_approval:
            return json.dumps({"error": "Fund Manager approval required. Process halted."})
        
        if compliance_review_required and not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required for this change. Process halted."})
        
        funds = data.get("funds", {})
        users = data.get("users", {})
        
        # Validate fund exists
        if str(fund_id) not in funds:
            return json.dumps({"error": f"Fund {fund_id} not found"})
        
        fund = funds[str(fund_id)]
        
        # Validate field against allowed fields and values
        allowed_fields = ["name", "fund_type", "manager_id", "size", "status"]
        valid_fund_types = ["mutual_funds", "exchange_traded_funds", "pension_funds", 
                           "private_equity_funds", "hedge_funds", "sovereign_wealth_funds", 
                           "money_market_funds", "real_estate_investment_trusts", 
                           "infrastructure_funds", "multi_asset_funds"]
        valid_statuses = ["open", "closed"]

        # Validate field name
        if field_name not in allowed_fields:
            return json.dumps({"error": f"Field '{field_name}' is not allowed to be updated"})

        # Validate specific field values
        if field_name == "fund_type" and field_value not in valid_fund_types:
            return json.dumps({"error": f"Invalid fund_type. Must be one of {valid_fund_types}"})

        if field_name == "status" and field_value not in valid_statuses:
            return json.dumps({"error": f"Invalid status. Must be one of {valid_statuses}"})

        if field_name == "manager_id" and str(field_value) not in users:
            return json.dumps({"error": f"Manager {field_value} not found"})

        if field_name == "size" and (not isinstance(field_value, (int, float)) or field_value < 0):
            return json.dumps({"error": "Fund size must be a non-negative number"})
        
        # Apply change
        timestamp = "2025-10-01T00:00:00"
        original_value = fund.get(field_name)
        
        # Update the field
        fund[field_name] = field_value
        fund["updated_at"] = timestamp
        
        # Create audit trail entry
        audit_trails = data.get("audit_trails", {})
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        # Only create audit trail if value actually changed
        if original_value != field_value:
            audit_id = generate_id(audit_trails)
            audit_record = {
                "audit_trail_id": audit_id,
                "reference_id": int(fund_id),
                "reference_type": "fund",
                "action": "update",
                "user_id": fund.get("manager_id", 1),  # Use manager as the updating user
                "field_name": field_name,
                "old_value": str(original_value) if original_value is not None else None,
                "new_value": str(field_value) if field_value is not None else None,
                "created_at": timestamp
            }
            audit_trails[str(audit_id)] = audit_record
        
        return json.dumps({
            "success": True, 
            "message": "Fund updated successfully",
            "fund_id": fund_id,
            "updated_field": field_name,
            "old_value": original_value,
            "new_value": field_value
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_fund",
                "description": "Update a single fund field with required approvals and audit trail",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "fund_id": {"type": "string", "description": "ID of the fund to update"},
                        "field_name": {
                            "type": "string", 
                            "description": "Name of the field to update",
                            "enum": ["name", "fund_type", "manager_id", "size", "status"]
                        },
                        "field_value": {
                            "description": "New value for the field (string, number, or boolean depending on field type)"
                        },
                        "fund_manager_approval": {"type": "boolean", "description": "Fund manager approval required (True or False)"},
                        "compliance_review_required": {"type": "boolean", "description": "Whether compliance review is required for this change (True for all changes)"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance officer approval (required if compliance_review_required is true). Its value is True"}
                    },
                    "required": ["fund_id", "field_name", "field_value", "fund_manager_approval"]
                }
            }
        }import json
from typing import Any, Dict, Optional
from tau_bench.envs.tool import Tool

class UpdateInstrument(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], instrument_id: str, proposed_changes: Dict[str, Any], 
            action, updated_by, compliance_review_required: Optional[bool]) -> str:
        
        def generate_id(table: Dict[str, Any]) -> int:
            if not table:
                return 1
            return max(int(k) for k in table.keys()) + 1
        
        instruments = data.get("instruments", {})
        users = data.get("users", {})
        audit_trails = data.get("audit_trails", {})
        
        # Validate instrument exists
        if str(instrument_id) not in instruments:
            return json.dumps({"success": False, "message": "Instrument not found"})
        

        # Validate proposed changes
        if not proposed_changes or not isinstance(proposed_changes, dict):
            return json.dumps({"success": False, "message": "Valid proposed changes required"})
        
        instrument = instruments[str(instrument_id)]
        
        # Check current status and validate action
        current_status = instrument.get("status", "active")
        if action.lower() == "deactivate" and current_status == "inactive":
            return json.dumps({"success": False, "message": "Instrument is already inactive"})
        elif action.lower() == "reactivate" and current_status == "active":
            return json.dumps({"success": False, "message": "Instrument is already active"})

        if not updated_by:
            return json.dumps({"success": False, "message": "No authorized user found to perform action"})
        
        # Update instrument status
        old_status = instrument.get("status")
        new_status = "inactive" if action.lower() == "deactivate" else "active"
        instrument["status"] = new_status
        
        # Create audit trail entry
        audit_id = generate_id(audit_trails)
        timestamp = "2025-10-01T00:00:00"
        
        audit_entry = {
            "audit_trail_id": audit_id,
            "reference_id": instrument_id,
            "reference_type": "instrument",
            "action": 'update',
            "user_id": updated_by,
            "field_name": "status",
            "old_value": old_status,
            "new_value": new_status,
            "created_at": timestamp
        }
        audit_trails[str(audit_id)] = audit_entry
        
        action_past = "Deactivated" if action.lower() == "deactivate" else "Reactivated"
        return json.dumps({
            "success": True, 
            "message": f"Instrument {action_past}", 
            "instrument_id": instrument_id
        })

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "deactivate_reactivate_instrument",
                "description": "Deactivate or reactivate an instrument",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "instrument_id": {"type": "string", "description": "ID of the instrument"},
                        "action": {"type": "string", "description": "Action to perform: deactivate or reactivate"},
                        "reason": {"type": "string", "description": "Reason for the action"},
                        "fund_manager_approval": {"type": "boolean", "description": "Fund Manager approval flag"},
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag"}
                    },
                    "required": ["instrument_id", "action", "reason", "fund_manager_approval", "compliance_officer_approval"]
                }
            }
        }
import json
from typing import Any, Dict
from tau_bench.envs.tool import Tool

class UpdateSubscription(Tool):
    @staticmethod
    def invoke(data: Dict[str, Any], subscription_id: str, field_name, field_value,
               compliance_officer_approval: bool, finance_officer_approval: bool) -> str:
        
        if not compliance_officer_approval:
            return json.dumps({"error": "Compliance Officer approval required. Process halted."})
        
        if not finance_officer_approval:
            return json.dumps({"error": "Finance Officer approval required. Process halted."})
        
        subscriptions = data.get("subscriptions", {})
        
        # Validate subscription exists
        if str(subscription_id) not in subscriptions:
            return json.dumps({"error": f"Subscription {subscription_id} not found"})
        
        subscription = subscriptions[str(subscription_id)]
        timestamp = "2025-10-01T00:00:00"
        
        # Apply changes
        if field_name in ["amount", "status"]:
            subscription[field_name] = field_value

        subscription["updated_at"] = timestamp

        return json.dumps({"subscription_after_update": subscription})

    @staticmethod
    def get_info() -> Dict[str, Any]:
        return {
            "type": "function",
            "function": {
                "name": "update_subscription",
                "description": "Update subscription details with required approvals",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "subscription_id": {"type": "string", "description": "ID of the subscription to update"},
                        "field_name": {
                            "type": "string",
                            "description": "Field to update (e.g., 'amount', 'status')"
                        },
                        "field_value": {
                            "type": "any",
                            "description": "New value for the field"
                        },
                        "compliance_officer_approval": {"type": "boolean", "description": "Compliance Officer approval flag (True/False)"},
                        "finance_officer_approval": {"type": "boolean", "description": "Finance Officer approval flag (True/False)"}
                    },
                    "required": ["subscription_id", "field_name", "field_value", "compliance_officer_approval", "finance_officer_approval"]
                }
            }
        }
